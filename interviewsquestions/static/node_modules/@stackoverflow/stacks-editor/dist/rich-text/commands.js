import { setBlockType, toggleMark, wrapIn, chainCommands, exitCode, } from "prosemirror-commands";
import { Selection } from "prosemirror-state";
import { liftTarget } from "prosemirror-transform";
import { imageUploaderEnabled, showImageUploader, } from "../shared/prosemirror-plugins/image-upload";
import { createMenuPlugin, makeMenuIcon, makeMenuLinkEntry, makeMenuSpacerEntry, addIf, makeMenuDropdown, dropdownItem, dropdownSection, } from "../shared/menu";
import { richTextSchema as schema, tableNodes } from "../shared/schema";
import { LINK_TOOLTIP_KEY } from "./plugins/link-tooltip";
import { undo, redo } from "prosemirror-history";
//TODO
function toggleWrapIn(nodeType) {
    var nodeCheck = nodeTypeActive(nodeType);
    var wrapInCommand = wrapIn(nodeType);
    return function (state, dispatch) {
        // if the node is not wrapped, go ahead and wrap it
        if (!nodeCheck(state)) {
            return wrapInCommand(state, dispatch);
        }
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        var range = $from.blockRange($to);
        // check if there is a valid target to lift to
        var target = range && liftTarget(range);
        // if we cannot unwrap, return false
        if (target == null) {
            return false;
        }
        if (dispatch) {
            dispatch(state.tr.lift(range, target));
        }
        return true;
    };
}
/** Command to set a block type to a paragraph (plain text) */
var setToTextCommand = setBlockType(schema.nodes.paragraph);
function toggleBlockType(nodeType, attrs) {
    var nodeCheck = nodeTypeActive(nodeType);
    var setBlockTypeCommand = setBlockType(nodeType, attrs);
    return function (state, dispatch) {
        // if the node is not set, go ahead and set it
        if (!nodeCheck(state)) {
            return setBlockTypeCommand(state, dispatch);
        }
        return setToTextCommand(state, dispatch);
    };
}
export function insertHorizontalRuleCommand(state, dispatch) {
    if (inTable(state.selection)) {
        return false;
    }
    dispatch &&
        dispatch(state.tr.replaceSelectionWith(schema.nodes.horizontal_rule.create()));
    return true;
}
export function inTable(selection) {
    return tableNodes.includes(selection.$head.parent.type);
}
function inTableHead(selection) {
    return selection.$head.parent.type === schema.nodes.table_header;
}
export var exitBlockCommand = chainCommands(exitCode, function (state, dispatch) {
    dispatch(state.tr
        .replaceSelectionWith(schema.nodes.hard_break.create())
        .scrollIntoView());
    return true;
});
export function moveSelectionAfterTableCommand(state, dispatch) {
    return exitTableCommand(state, dispatch, false);
}
export function moveSelectionBeforeTableCommand(state, dispatch) {
    return exitTableCommand(state, dispatch, true);
}
function exitTableCommand(state, dispatch, before) {
    if (before === void 0) { before = false; }
    if (!inTable(state.selection)) {
        return false;
    }
    if (dispatch) {
        // our hierarchy is table > table_head | table_body > table_row > table_cell
        // and we're relying on that to be always true.
        // That's why .after(-3) selects the parent _table_ node from a table_cell node
        var type = schema.nodes.paragraph;
        var newPosition = before
            ? state.selection.$head.before(-3) - 1
            : state.selection.$head.after(-3) + 1;
        var tr = state.tr;
        // if the position before/after the table doesn't exist, let's insert a paragraph there
        try {
            tr.doc.resolve(newPosition);
        }
        catch (e) {
            var insertionPosition = before
                ? newPosition + 1
                : newPosition - 1;
            tr.insert(insertionPosition, type.create());
        }
        tr.setSelection(Selection.near(tr.doc.resolve(Math.max(0, newPosition)), 1));
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function insertTableRowBeforeCommand(state, dispatch) {
    return insertTableRowCommand(true, state, dispatch);
}
export function insertTableRowAfterCommand(state, dispatch) {
    return insertTableRowCommand(false, state, dispatch);
}
function insertTableRowCommand(before, state, dispatch) {
    if (!inTable(state.selection) || inTableHead(state.selection)) {
        return false;
    }
    if (dispatch) {
        var $head = state.selection.$head;
        var tableRowNode = $head.node(-1);
        var newTableCells_1 = [];
        tableRowNode.forEach(function (cell) {
            newTableCells_1.push(schema.nodes.table_cell.create(cell.attrs));
        });
        var newTableRow = schema.nodes.table_row.create(null, newTableCells_1);
        var positionToInsert = before ? $head.before(-1) : $head.after(-1);
        var tr = state.tr.insert(positionToInsert, newTableRow);
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function insertTableColumnAfterCommand(state, dispatch) {
    return insertTableColumnCommand(false, state, dispatch);
}
export function insertTableColumnBeforeCommand(state, dispatch) {
    return insertTableColumnCommand(true, state, dispatch);
}
/**
 *  Insert a new table column in this table
 * 1. find the index of the selected table cell in the current table row
 * 2. walk through the entire document to traverse all rows in our selected table
 * 3. for each table row, find the table cell at the desired index and get its position
 * 4. insert a new table_cell or table_header node before/after the found position
 */
function insertTableColumnCommand(before, state, dispatch) {
    if (!inTable(state.selection)) {
        return false;
    }
    if (dispatch) {
        var $head = state.selection.$head;
        var selectedTable_1 = $head.node(-3);
        var selectedCellIndex_1 = $head.index(-1);
        // find and store all positions where we need to insert new cells
        var newCells_1 = [];
        var tableOffset_1 = $head.start(-3);
        var targetCell_1;
        // traverse the current table to find the absolute positions of our cells to be inserted
        selectedTable_1.descendants(function (node, pos) {
            if (!tableNodes.includes(node.type)) {
                return false; // don't descend into non-table nodes
            }
            if (node.type === schema.nodes.table_row) {
                targetCell_1 = node.child(selectedCellIndex_1);
            }
            if (targetCell_1 && node == targetCell_1) {
                var position = before
                    ? selectedTable_1.resolve(pos + 1).before()
                    : selectedTable_1.resolve(pos + 1).after();
                // position is relative to the start of the table, so we need
                // to add the table offset (distance to start of document)
                newCells_1.push([node.type, tableOffset_1 + position]);
            }
        });
        // insert new cells from bottom to top (reverse order)
        // to avoid inserted cells making our found positions obsolete
        var tr = state.tr;
        for (var _i = 0, _a = newCells_1.reverse(); _i < _a.length; _i++) {
            var newCell = _a[_i];
            tr = tr.insert(newCell[1], newCell[0].create());
        }
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function removeRowCommand(state, dispatch) {
    if (!inTable(state.selection) || inTableHead(state.selection)) {
        return false;
    }
    if (dispatch) {
        var tr = state.tr;
        var $head = state.selection.$head;
        // delete entire table if we're deleting the last row in the table body
        if ($head.node(-2).childCount === 1) {
            return removeTableCommand(state, dispatch);
        }
        // delete from start to end of this row (node at -1 position from the table cell)
        tr.delete($head.start(-1) - 1, $head.end(-1) + 1);
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function removeColumnCommand(state, dispatch) {
    if (!inTable(state.selection)) {
        return false;
    }
    if (dispatch) {
        var $head = state.selection.$head;
        var table_1 = $head.node(-3);
        // remove entire table if this is the last remaining column
        if ($head.node(-1).childCount === 1) {
            return removeTableCommand(state, dispatch);
        }
        var cellIndex_1 = $head.index(-1);
        var targetCell_2;
        var resolvedPositions_1 = [];
        var tableOffset = $head.start(-3);
        table_1.descendants(function (node, pos) {
            if (!tableNodes.includes(node.type)) {
                return false; // don't descend into non-table nodes
            }
            if (node.type === schema.nodes.table_row) {
                targetCell_2 =
                    node.childCount >= cellIndex_1 + 1
                        ? node.child(cellIndex_1)
                        : null;
            }
            if (targetCell_2 && node == targetCell_2) {
                resolvedPositions_1.push(table_1.resolve(pos + 1));
            }
        });
        var tr = state.tr;
        for (var _i = 0, _a = resolvedPositions_1.reverse(); _i < _a.length; _i++) {
            var cellPosition = _a[_i];
            tr = tr.delete(tableOffset + cellPosition.start() - 1, tableOffset + cellPosition.end() + 1);
        }
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function removeTableContentCommand(state, dispatch) {
    if (!inTable(state.selection)) {
        return false;
    }
    var _a = state.selection, $from = _a.$from, $to = _a.$to;
    // selection includes entire table
    if ($from.start(-3) >= $from.pos - 3 && $from.end(-3) <= $to.pos + 3) {
        return removeTableCommand(state, dispatch);
    }
    // selection includes entire row
    if ($from.start(-1) >= $from.pos - 1 && $from.end(-1) <= $to.pos + 1) {
        return removeRowCommand(state, dispatch);
    }
    // selection contains two arbitrary cells?
    // prevent delete operation to prevent deleting the cell nodes
    // themselves and breaking the table structure
    if (!$from.sameParent($to)) {
        return true;
    }
    return false;
}
function moveToCellCommand(state, dispatch, direction) {
    if (direction !== -1 && direction !== 1) {
        return false;
    }
    if (!inTable(state.selection))
        return false;
    var $head = state.selection.$head;
    for (var level = -1; level > -4; level--) {
        var parentIndex = $head.index(level);
        var parent_1 = $head.node(level);
        if (!parent_1)
            continue;
        // every time we want to skip the boundaries of a node (a cell, a row, ...)
        // we have to consider the node's opening and closing positions, too. For
        // each level, this will add an additional offset of 2 that we need to skip
        var nodeOffset = 2;
        var target = parent_1.maybeChild(parentIndex + direction);
        if (!target)
            continue;
        var newPos = direction === -1
            ? $head.start() - nodeOffset * (level * -1)
            : $head.end() + nodeOffset * (level * -1);
        dispatch(state.tr
            .setSelection(Selection.near(state.tr.doc.resolve(newPos), 1))
            .scrollIntoView());
        return true;
    }
    // we're at the end of the table and still want to move forward?
    // let's move the cursor below the table!
    if (direction === 1) {
        return moveSelectionAfterTableCommand(state, dispatch);
    }
    else {
        return moveSelectionBeforeTableCommand(state, dispatch);
    }
}
export function moveToPreviousCellCommand(state, dispatch) {
    return moveToCellCommand(state, dispatch, -1);
}
export function moveToNextCellCommand(state, dispatch) {
    return moveToCellCommand(state, dispatch, +1);
}
function removeTableCommand(state, dispatch) {
    var $head = state.selection.$head;
    if (dispatch) {
        dispatch(state.tr.deleteRange($head.start(-3) - 1, $head.end(-3) + 1));
    }
    return true;
}
export function insertTableCommand(state, dispatch) {
    if (!setBlockType(schema.nodes.table)(state)) {
        return false;
    }
    if (!dispatch)
        return true;
    var headerIndex = 1;
    var cellIndex = 1;
    var cell = function () {
        return schema.nodes.table_cell.create(null, schema.text("cell " + cellIndex++));
    };
    var header = function () {
        return schema.nodes.table_header.create(null, schema.text("header " + headerIndex++));
    };
    var row = function () {
        var cells = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            cells[_i] = arguments[_i];
        }
        return schema.nodes.table_row.create(null, cells);
    };
    var head = function (row) {
        return schema.nodes.table_head.create(null, row);
    };
    var body = function () {
        var rows = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rows[_i] = arguments[_i];
        }
        return schema.nodes.table_body.create(null, rows);
    };
    var table = function (head, body) {
        return schema.nodes.table.createChecked(null, [head, body]);
    };
    var paragraph = function () { return schema.nodes.paragraph.create(null); };
    var t = table(head(row(header(), header())), body(row(cell(), cell()), row(cell(), cell())));
    var tr = state.tr.replaceSelectionWith(t);
    dispatch(tr.scrollIntoView());
    // if there's no selectable node after the inserted table, insert an empty paragraph
    // because it makes selecting, navigating much more intuitive
    var newState = state.apply(tr);
    var nodeAfterTable = newState.doc.nodeAt(newState.tr.selection.to - 1);
    if (nodeAfterTable && nodeAfterTable.type === schema.nodes.text) {
        tr = newState.tr.insert(newState.tr.selection.to, paragraph());
        dispatch(tr.scrollIntoView());
    }
    return true;
}
export function insertImageCommand(state, dispatch, view) {
    if (!imageUploaderEnabled(view)) {
        return false;
    }
    if (!dispatch)
        return true;
    showImageUploader(view);
    return true;
}
export function insertLinkCommand(state, dispatch, view) {
    var _a, _b;
    if (state.selection.empty)
        return false;
    if (dispatch) {
        var selectedText = (_b = (_a = state.selection.content().content.firstChild) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : null;
        var linkMatch = /^http(s)?:\/\/\S+$/.exec(selectedText);
        var linkUrl = (linkMatch === null || linkMatch === void 0 ? void 0 : linkMatch.length) > 0 ? linkMatch[0] : "";
        var isInserting = toggleMark(schema.marks.link, { href: linkUrl })(state, dispatch);
        if (isInserting) {
            var tr = LINK_TOOLTIP_KEY.setEditMode(true, state, view.state.tr);
            view.dispatch(tr);
        }
    }
    return true;
}
/**
 * Creates an `active` method that returns true of the current selection is/contained in the current block type
 * @param nodeType The type of the node to check for
 */
function nodeTypeActive(nodeType) {
    return function (state) {
        var _a = state.selection, from = _a.from, to = _a.to;
        var isNodeType = false;
        // check all nodes in the selection for the right type
        state.doc.nodesBetween(from, to, function (node) {
            isNodeType = node.type.name === nodeType.name;
            // stop recursing if the current node is the right type
            return !isNodeType;
        });
        return isNodeType;
    };
}
/**
 * Creates an `active` method that returns true of the current selection has the passed mark
 * @param mark The mark to check for
 */
function markActive(mark) {
    return function (state) {
        var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
        if (empty) {
            return !!mark.isInSet(state.storedMarks || $from.marks());
        }
        else {
            return state.doc.rangeHasMark(from, to, mark);
        }
    };
}
export var createMenu = function (options) {
    var _a;
    return createMenuPlugin([
        {
            key: "toggleHeading",
            command: toggleBlockType(schema.nodes.heading, { level: 1 }),
            dom: makeMenuIcon("Header", "Heading", "heading-btn"),
            active: nodeTypeActive(schema.nodes.heading),
        },
        {
            key: "toggleBold",
            command: toggleMark(schema.marks.strong),
            dom: makeMenuIcon("Bold", "Bold", "bold-btn"),
            active: markActive(schema.marks.strong),
        },
        {
            key: "toggleEmphasis",
            command: toggleMark(schema.marks.em),
            dom: makeMenuIcon("Italic", "Italic", "italic-btn"),
            active: markActive(schema.marks.em),
        },
        {
            key: "toggleCode",
            command: toggleMark(schema.marks.code),
            dom: makeMenuIcon("Code", "Inline code", "code-btn"),
            active: markActive(schema.marks.code),
        },
        addIf({
            key: "toggleStrike",
            command: toggleMark(schema.marks.strike),
            dom: makeMenuIcon("Strikethrough", "Strikethrough", "strike-btn"),
            active: markActive(schema.marks.strike),
        }, options.parserFeatures.extraEmphasis),
        makeMenuSpacerEntry(),
        {
            key: "toggleLink",
            command: insertLinkCommand,
            dom: makeMenuIcon("Link", "Link selection", "insert-link-btn"),
        },
        {
            key: "toggleBlockquote",
            command: toggleWrapIn(schema.nodes.blockquote),
            dom: makeMenuIcon("Quote", "Blockquote", "blockquote-btn"),
            active: nodeTypeActive(schema.nodes.blockquote),
        },
        {
            key: "toggleCodeblock",
            command: toggleBlockType(schema.nodes.code_block),
            dom: makeMenuIcon("Codeblock", "Code block", "code-block-btn"),
            active: nodeTypeActive(schema.nodes.code_block),
        },
        addIf({
            key: "insertImage",
            command: insertImageCommand,
            dom: makeMenuIcon("Image", "Image", "insert-image-btn"),
        }, !!((_a = options.imageUpload) === null || _a === void 0 ? void 0 : _a.handler)),
        addIf({
            key: "insertTable",
            command: insertTableCommand,
            dom: makeMenuIcon("Table", "Table", "insert-table-btn"),
            visible: function (state) { return !inTable(state.selection); },
        }, options.parserFeatures.tables),
        addIf(tableDropdown, options.parserFeatures.tables),
        makeMenuSpacerEntry(),
        {
            key: "toggleOrderedList",
            command: toggleWrapIn(schema.nodes.ordered_list),
            dom: makeMenuIcon("OrderedList", "Numbered list", "numbered-list-btn"),
            active: nodeTypeActive(schema.nodes.ordered_list),
        },
        {
            key: "toggleUnorderedList",
            command: toggleWrapIn(schema.nodes.bullet_list),
            dom: makeMenuIcon("UnorderedList", "Bulleted list", "bullet-list-btn"),
            active: nodeTypeActive(schema.nodes.bullet_list),
        },
        {
            key: "insertRule",
            command: insertHorizontalRuleCommand,
            dom: makeMenuIcon("HorizontalRule", "Horizontal rule", "horizontal-rule-btn"),
        },
        makeMenuSpacerEntry(function () { return false; }, ["sm:d-inline-block"]),
        {
            key: "undo",
            command: undo,
            dom: makeMenuIcon("Undo", "Undo", "undo-btn", [
                "sm:d-inline-block",
            ]),
            visible: function () { return false; },
        },
        {
            key: "redo",
            command: redo,
            dom: makeMenuIcon("Refresh", "Redo", "redo-btn", [
                "sm:d-inline-block",
            ]),
            visible: function () { return false; },
        },
        makeMenuSpacerEntry(),
        //TODO eventually this will mimic the "help" dropdown in the prod editor
        makeMenuLinkEntry("Help", "Help", options.editorHelpLink),
    ], options.menuParentContainer);
};
var tableDropdown = makeMenuDropdown("Table", "Edit table", "table-dropdown", function (state) { return inTable(state.selection); }, dropdownSection("Column", "columnSection"), dropdownItem("Remove column", removeColumnCommand, "remove-column-btn"), dropdownItem("Insert column before", insertTableColumnBeforeCommand, "insert-column-before-btn"), dropdownItem("Insert column after", insertTableColumnAfterCommand, "insert-column-after-btn"), dropdownSection("Row", "rowSection"), dropdownItem("Remove row", removeRowCommand, "remove-row-btn"), dropdownItem("Insert row before", insertTableRowBeforeCommand, "insert-row-before-btn"), dropdownItem("Insert row after", insertTableRowAfterCommand, "insert-row-after-btn"));
