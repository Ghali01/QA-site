import { Decoration, DecorationSet } from "prosemirror-view";
import { AsyncPlugin, AsyncPluginKey, } from "../../shared/prosemirror-plugins/plugin-extensions";
// TODO naive cache, maybe we can improve?
// TODO maybe we can prefill the cache if the consuming process already has the result
/** The cache of url -> content for link previews so we don't have to continually refetch */
var previewResultCache = {};
/**
 * Gets the first valid provider for a node from all registered providers
 * @param providers All registered providers
 * @param node The node to check for applicable links to match to the registered providers
 */
function getValidProvider(providers, node) {
    var _a, _b;
    // not a valid node, keep checking
    if (!isPreviewableLink(node)) {
        return null;
    }
    var child = node.content.firstChild;
    var url = (_b = (_a = child.marks.find(function (m) { return m.type.name === "link"; })) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.href;
    // if there is no href, then nothing will match
    if (!url) {
        return null;
    }
    // check all providers for this
    for (var _i = 0, providers_1 = providers; _i < providers_1.length; _i++) {
        var provider = providers_1[_i];
        if (provider.domainTest && provider.domainTest.test(url)) {
            return { url: url, provider: provider };
        }
    }
    return null;
}
/**
 * Generates a placeholder to show while fetching preview content;
 * Generated placeholder is also used as the final container for the fetched content
 */
function generatePlaceholder() {
    // TODO make this look nice
    var placeholder = document.createElement("div");
    // give this a targetable class for external use / e2e testing
    placeholder.className = "js-placeholder";
    // everything inside the placeholder will be replaced on render
    placeholder.innerHTML = "<div class=\"s-spinner s-spinner__xs\"></div>";
    return placeholder;
}
/**
 * Gets nodes in the document that are able to be resolved by a preview provider
 * @param doc The document to search through
 * @param providers The list of registered providers
 */
function getValidNodes(doc, providers) {
    var validNodes = [];
    // iterate over document structure
    doc.descendants(function (node, pos) {
        var provider = getValidProvider(providers, node);
        if (provider) {
            validNodes.push({ provider: provider, pos: pos, node: node });
            // no need to go into this node's descendants
            return false;
        }
    });
    return validNodes;
}
/**
 * TODO: fire a transaction to update the view after the placeholder is insert
 *
 * Run over the entire document and find all previewable links and create a link preview decoration
 * for each.
 * @param {Document} doc - The document to find previewable link candidates in
 */
function generatePreviewDecorations(doc, providers) {
    var linkPreviewDecorations = [];
    var nodes = getValidNodes(doc, providers);
    nodes.forEach(function (n) {
        var placeholder = generatePlaceholder();
        linkPreviewDecorations.push(Decoration.widget(n.pos, placeholder));
        // if the url is in the cache, insert
        if (n.provider.url in previewResultCache) {
            insertLinkPreview(placeholder, previewResultCache[n.provider.url]);
        }
    });
    return DecorationSet.create(doc, linkPreviewDecorations);
}
/**
 * Inserts the link preview's content into the link's decoration/placeholder
 * @param placeholder The placeholder originally created to house this content
 * @param content The content returned from the link preview to insert
 */
function insertLinkPreview(placeholder, content) {
    // empty the placeholder content to remove the spinner / old content
    placeholder.innerHTML = "";
    // nothing to append, just return empty
    if (!content) {
        return;
    }
    placeholder.appendChild(content);
}
/**
 * Figure out if a given node in the document is a candidate for a link preview.
 * This will find all paragraphs that consist only of a link and nothing else.
 *
 * @param {Node} node - The node that should be checked
 */
function isPreviewableLink(node) {
    var child = node.content.firstChild;
    if (!child)
        return false;
    var hasOnlyOneChild = node.childCount === 1;
    var childIsTextNode = child.type.name === "text";
    var childHasLinkMark = child.marks.some(function (mark) { return mark.type.name === "link"; });
    return hasOnlyOneChild && childIsTextNode && childHasLinkMark;
}
/**
 * Fetches and caches all link preview content for every link node in the view
 * @param view The view to search for valid link nodes
 * @param providers The list of registered providers
 */
function fetchLinkPreviewContent(view, providers) {
    // TODO can we make this more efficient?
    // getValidNodes will run on every state update, so it'd be
    // nice to be able to check the last transaction / updated doc
    // instead of the current snapshot
    var nodes = getValidNodes(view.state.doc, providers);
    // filter out all urls that are already in cache
    var unfetchedNodes = nodes.filter(function (n) { return !(n.provider.url in previewResultCache); });
    // if there's no data to fetch, just reject (no need to update the state)
    if (!unfetchedNodes.length) {
        return Promise.reject(null);
    }
    // start fetching all content
    var promises = unfetchedNodes.map(function (n) {
        return (n.provider.provider
            .renderer(n.provider.url)
            .then(function (content) {
            // cache results so we don't call over and over...
            previewResultCache[n.provider.url] = content;
            return content;
        })
            // don't let any errors crash our `.all` below
            // "catch" and fake a resolution
            .catch(function () {
            // TODO make this look nice
            var errorPlaceholder = document.createElement("div");
            errorPlaceholder.innerText = "Error fetching content.";
            // set the cache here too, so we don't refetch errors every time...
            previewResultCache[n.provider.url] = errorPlaceholder;
            return Promise.resolve(errorPlaceholder);
        }));
    });
    return Promise.all(promises);
}
var LINK_PREVIEWS_KEY = new AsyncPluginKey("linkPreviews");
/**
 * Creates a plugin that searches the entire document for potentially previewable links
 * and creates a widget decoration to render the link preview in.
 */
export function linkPreviewPlugin(providers) {
    providers = providers || [];
    return new AsyncPlugin({
        key: LINK_PREVIEWS_KEY,
        asyncCallback: function (view) {
            return fetchLinkPreviewContent(view, providers);
        },
        state: {
            init: function (_, _a) {
                var doc = _a.doc;
                return generatePreviewDecorations(doc, providers);
            },
            apply: function (tr, value) {
                // only update the decorations if they changed at all
                if (this.getCallbackData(tr)) {
                    return generatePreviewDecorations(tr.doc, providers);
                }
                // else update the mappings to their new positions in the doc
                return value.map(tr.mapping, tr.doc);
            },
        },
        props: {
            decorations: function (state) {
                return this.getState(state);
            },
        },
    });
}
