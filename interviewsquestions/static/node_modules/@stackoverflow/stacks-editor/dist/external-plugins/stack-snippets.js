var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
import { escapeHTML } from "../shared/utils";
var StackSnippetsView = /** @class */ (function () {
    function StackSnippetsView(node) {
        this.dom = document.createElement("div");
        this.dom.classList.add("ws-normal", "ow-normal");
        // get the data from the stack snippet tag and parse
        // looks like `js hide: [boolean] console: [boolean] babel: [boolean]`
        var rawDataString = node.attrs.data;
        this.state = StackSnippetsView.getSnippetArgs(rawDataString);
        //TODO hack?
        this.dom.innerHTML = escapeHTML(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n<div class=\"s-link-preview\" data-language=\"", "\"\n     data-hide=\"", "\"\n     data-console=\"", "\"\n     data-babel=\"", "\">\n    <div class=\"s-link-preview--header ai-center py4\">\n        <div class=\"s-link-preview--title fs-body1 fl-grow1\">Code snippet</div>\n        <div>\n            <button class=\"s-btn s-btn__muted fc-success s-btn__icon s-btn__xs flex--item js-not-implemented\" title=\"Run code snippet\">\n                <span class=\"icon-bg iconPlay\"></span>\n            </button>\n            <button class=\"s-btn s-btn__muted s-btn__icon s-btn__xs flex--item js-not-implemented\" title=\"Expand snippet\">\n                <span class=\"icon-bg iconShare\"></span>\n            </button>\n        </div>\n    </div>\n    <div id=\"content-dom\"></div>\n</div>\n        "], ["\n<div class=\"s-link-preview\" data-language=\"", "\"\n     data-hide=\"", "\"\n     data-console=\"", "\"\n     data-babel=\"", "\">\n    <div class=\"s-link-preview--header ai-center py4\">\n        <div class=\"s-link-preview--title fs-body1 fl-grow1\">Code snippet</div>\n        <div>\n            <button class=\"s-btn s-btn__muted fc-success s-btn__icon s-btn__xs flex--item js-not-implemented\" title=\"Run code snippet\">\n                <span class=\"icon-bg iconPlay\"></span>\n            </button>\n            <button class=\"s-btn s-btn__muted s-btn__icon s-btn__xs flex--item js-not-implemented\" title=\"Expand snippet\">\n                <span class=\"icon-bg iconShare\"></span>\n            </button>\n        </div>\n    </div>\n    <div id=\"content-dom\"></div>\n</div>\n        "])), this.state.language, this.state.hide.toString(), this.state.console.toString(), this.state.babel.toString());
        // set the area where prosemirror will insert the node's children
        this.contentDOM = this.dom.querySelector("#content-dom");
        //TODO launch snippet modal
        this.dom.querySelectorAll(".js-not-implemented").forEach(function (el) {
            el.addEventListener("click", function (e) {
                e.stopPropagation();
                // eslint-disable-next-line no-alert
                alert("Sorry, this doesn't work yet :)");
            });
        });
    }
    StackSnippetsView.prototype.stopEvent = function () {
        return true;
    };
    /**
     * Parses out the snippet args from its raw data string
     * @param rawDataString the entire raw snippet data string that looks like `js hide: [boolean] console: [boolean] babel: [boolean]`
     */
    StackSnippetsView.getSnippetArgs = function (rawDataString) {
        var matches = /(.+?) hide: (true|false) console: (true|false) babel: (true|false)/.exec(rawDataString);
        return {
            language: matches[1] || "js",
            hide: matches[2] === "true",
            console: matches[3] === "true",
            babel: matches[4] === "true",
        };
    };
    return StackSnippetsView;
}());
/**
 * Parser rule for stack_snippet and stack_snippet lang, partial based / piecemealed from other markdown-it block rules
 * @param state
 * @param startLine
 * @param endLine
 * @param silent
 */
function stackSnippetsMarkdownPluginImpl(state, startLine, endLine, silent) {
    var pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    // Check start
    if (state.src.charCodeAt(pos) !== 0x3c /* < */ || pos + 2 >= max) {
        return false;
    }
    // Quick fail on second char
    var ch = state.src.charCodeAt(pos + 1);
    if (ch !== 0x21 /* ! */) {
        return false;
    }
    // match the first half
    //TODO what are all the different things we can have inside? Does it matter?
    var lineText = state.src.slice(pos, max);
    var matches = /^<!-- begin snippet: (.+?) -->/.exec(lineText);
    if (!(matches === null || matches === void 0 ? void 0 : matches.length)) {
        return false;
    }
    if (silent) {
        return true;
    }
    var oldLineMax = state.lineMax;
    var oldParentType = state.parentType;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore TODO necessary?
    state.parentType = "stack_snippet";
    var nextLine = startLine + 1;
    var endRegex = /<!-- end snippet -->/;
    var lastNonEmpty = nextLine;
    while (nextLine < endLine) {
        for (; nextLine < endLine; nextLine++) {
            pos = state.bMarks[nextLine] + state.tShift[nextLine];
            max = state.eMarks[nextLine];
            lineText = state.src.slice(pos, max);
            if (lineText.length) {
                lastNonEmpty = nextLine;
            }
            // if this is the end of the snippet, break from the loop
            if (endRegex.test(lineText)) {
                if (lineText.length) {
                    nextLine++;
                }
                break;
            }
        }
        nextLine++;
    }
    state.lineMax = lastNonEmpty;
    var token = state.push("stack_snippet_open", "", 1);
    token.map = [startLine, 0];
    // set the entire snippet data string as an attribute
    token.attrSet("data", matches[1]);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    state.md.block.tokenize(state, startLine + 1, lastNonEmpty);
    token.map[1] = endLine;
    token = state.push("stack_snippet_close", "", -1);
    state.line = endLine + 1;
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    return true;
}
/**
 * Parses out `stack_snippet`s
 * @param md
 */
function stackSnippetsMarkdownPlugin(md) {
    md.block.ruler.before("html_block", "stack_snippets", stackSnippetsMarkdownPluginImpl);
}
export var StackSnippetsPlugin = {
    markdownParser: {
        tokens: {
            stack_snippet: {
                block: "stack_snippet",
                getAttrs: function (tok) { return ({
                    content: tok.content,
                    data: tok.attrGet("data"),
                }); },
            },
        },
        plugins: [stackSnippetsMarkdownPlugin],
    },
    markdownSerializers: {
        stack_snippet: function (state, node) {
            //const args = StackSnippetsView.getSnippetArgs(node.attrs.data);
            //TODO for some reason converting back to rich text breaks when the interior items are fences... commenting out for now
            // state.write(
            //     `<!-- begin snippet: ${args.language} hide:${args.hide} console:${args.console} babel:${args.babel} -->\n\n`
            // );
            state.renderContent(node);
            state.ensureNewLine();
            //state.write("<!-- end snippet -->");
        },
    },
    menuEntries: [],
    nodeViews: {
        stack_snippet: function (node) {
            return new StackSnippetsView(node);
        },
    },
    plugins: [],
    schema: {
        nodes: {
            stack_snippet: {
                content: "code_block*",
                attrs: { content: { default: "" }, data: { default: "" } },
                marks: "",
                group: "block",
                inline: false,
                selectable: true,
                isolating: true,
            },
        },
    },
};
var templateObject_1;
