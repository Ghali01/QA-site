var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { escapeHtml } from "markdown-it/lib/common/utils";
/**
 * Recursively deep merges two objects into a new object, leaving the original two untouched
 * NOTE: Arrays are only shallow merged
 * @param object1 The object to base the merge off of
 * @param object2 The object to merge into the base object
 */
export function deepMerge(object1, object2) {
    return mergeObject(object1, object2);
}
function isPlainObject(obj) {
    // not an object type
    if (!(obj instanceof Object)) {
        return false;
    }
    if (obj instanceof Function) {
        return false;
    }
    if (obj instanceof Array) {
        return false;
    }
    // probably an object
    return true;
}
function mergeObject(object1, object2) {
    // if both are arrays, shallow merge (else, non-object merge)
    if (object1 instanceof Array && object2 instanceof Array) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-assignment
        return __spreadArray(__spreadArray([], object1), object2);
    }
    var obj1IsObject = isPlainObject(object1);
    var obj2IsObject = isPlainObject(object2);
    // if the first item is not an object, return a clone of the second
    if (!obj1IsObject && obj2IsObject) {
        return mergeObject({}, object2);
    }
    // if the second is not an object, return a clone of the first
    else if (obj1IsObject && !obj2IsObject) {
        return mergeObject({}, object1);
    }
    // if neither are objects, return the second item
    else if (!obj1IsObject && !obj2IsObject) {
        return object2;
    }
    var outObject = {};
    // we know these are objects (from above), so retype them now
    var obj1 = object1;
    var obj2 = object2;
    // start merging all the keys from the first object
    var keys = Object.keys(obj1);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (key in obj2) {
            outObject[key] = mergeObject(obj1[key], obj2[key]);
        }
        else {
            outObject[key] = obj1[key];
        }
    }
    // set all leftover keys from object2
    keys = Object.keys(obj2);
    for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
        var key = keys_2[_a];
        // we already merged these keys, skip
        if (key in outObject) {
            continue;
        }
        outObject[key] = obj2[key];
    }
    return outObject;
}
/**
 * Compares two states and returns true if the doc has changed between them.
 * The doc is considered changed if:
 *      * its content changed
 *      * the selection has changed
 *      * the stored marks have changed
 * @param prevState The "old" / previous editor state
 * @param newState The "new" / current editor state
 */
export function docChanged(prevState, newState) {
    // if either are null, just return "changed"
    if (!prevState || !newState) {
        return true;
    }
    return (!prevState.selection.eq(newState.selection) ||
        !prevState.doc.eq(newState.doc) ||
        prevState.storedMarks !== newState.storedMarks);
}
/** The class to attach sticky observers to */
export var STICKY_OBSERVER_CLASS = "js-sticky";
// TODO should this go into Stacks proper?
/**
 * Starts observers watching all .STICKY_OBSERVER_CLASS elements for a change in stuck position
 * @param container The container to search for STICKY_OBSERVER_CLASS elements (usually the closest scrolling parent)
 * @fires sticky-change
 */
export function startStickyObservers(container) {
    var observer = new IntersectionObserver(function (entries) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            var stuck = !entry.isIntersecting;
            var target = entry.target.nextElementSibling;
            /**
             * sticky-change event
             * @event sticky-change
             * @type {object}
             * @property {boolean} detail.stuck - Indicates whether the target is stuck
             * @property {Element} detail.target - The targeted position:sticky element
             */
            var e = new CustomEvent("sticky-change", {
                detail: { stuck: stuck, target: target },
            });
            document.dispatchEvent(e);
        }
    }, {
        threshold: [0],
        root: container,
    });
    container.querySelectorAll("." + STICKY_OBSERVER_CLASS).forEach(function (el) {
        var sentinel = document.createElement("div");
        // not altogether necessary, but let's label the div so others know what this is and where it is coming from
        sentinel.className = "js-sticky-sentinel";
        // add right before the sticky element; if this element becomes obscured, then the sticky is unstuck
        el.parentNode.insertBefore(sentinel, el);
        observer.observe(sentinel);
    });
}
// rudimentary link validation that's roughly in line with what Stack Overflow's backend uses for validation
var validLinkRegex = /^((https?|ftp):\/\/|\/)[-a-z0-9+&@#/%?=~_|!:,.;()*[\]$]+$/;
var validMailtoRegex = /^mailto:[#-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+$/;
/**
 * Checks if a url is well-formed as passes validation checks
 * @param url The url to validate
 */
export function validateLink(url) {
    var normalizedUrl = url === null || url === void 0 ? void 0 : url.trim().toLowerCase();
    return (validLinkRegex.test(normalizedUrl) ||
        validMailtoRegex.test(normalizedUrl));
}
/**
 * Template function to escape all html in substitions, but not the rest of the template.
 * For instance, escapeHTML`<p>${"<span>user input</span>"}</p>` will escape the inner span, but not the outer p tags.
 * Uses markdown-it's @see escapeHtml in the background
 */
export function escapeHTML(strings) {
    var _a;
    var subs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        subs[_i - 1] = arguments[_i];
    }
    var output = strings[0];
    for (var i = 0, len = subs.length; i < len; i++) {
        output += escapeHtml(((_a = subs[i]) === null || _a === void 0 ? void 0 : _a.toString()) || "") + strings[i + 1];
    }
    return output;
}
