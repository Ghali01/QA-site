var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Plugin, PluginKey, } from "prosemirror-state";
import { log } from "../logger";
var StatefulPluginKey = /** @class */ (function (_super) {
    __extends(StatefulPluginKey, _super);
    function StatefulPluginKey(name) {
        return _super.call(this, name) || this;
    }
    /** @inheritdoc */
    StatefulPluginKey.prototype.get = function (state) {
        return _super.prototype.get.call(this, state);
    };
    StatefulPluginKey.prototype.setMeta = function (tr, data) {
        return tr.setMeta(this, data);
    };
    return StatefulPluginKey;
}(PluginKey));
export { StatefulPluginKey };
var StatefulPlugin = /** @class */ (function (_super) {
    __extends(StatefulPlugin, _super);
    function StatefulPlugin(spec) {
        return _super.call(this, spec) || this;
    }
    Object.defineProperty(StatefulPlugin.prototype, "transactionKey", {
        get: function () {
            return this.spec.key;
        },
        enumerable: false,
        configurable: true
    });
    StatefulPlugin.prototype.getMeta = function (tr) {
        return tr.getMeta(this.transactionKey);
    };
    return StatefulPlugin;
}(Plugin));
export { StatefulPlugin };
var AsyncPluginKey = /** @class */ (function (_super) {
    __extends(AsyncPluginKey, _super);
    function AsyncPluginKey(name) {
        return _super.call(this, name) || this;
    }
    /** @inheritdoc */
    AsyncPluginKey.prototype.setMeta = function (tr, data) {
        var wrappedData = {
            callbackData: null,
            state: data,
        };
        return tr.setMeta(this, wrappedData);
    };
    AsyncPluginKey.prototype.setCallbackData = function (tr, data) {
        var wrappedData = {
            callbackData: data,
            state: null,
        };
        return tr.setMeta(this, wrappedData);
    };
    return AsyncPluginKey;
}(StatefulPluginKey));
export { AsyncPluginKey };
var AsyncViewHandler = /** @class */ (function () {
    function AsyncViewHandler(view, transactionKey, callback) {
        this.callback = callback;
        this.transactionKey = transactionKey;
        // go ahead and call this first to initialize the plugin
        this.attachCallback(view, null);
    }
    // on document update, call the callback again
    AsyncViewHandler.prototype.update = function (view, prevState) {
        // if the doc didn't change, don't update
        if (view.state.doc.eq(prevState.doc)) {
            return;
        }
        // attach a new callback to this instance
        this.attachCallback(view, prevState);
    };
    AsyncViewHandler.prototype.destroy = function () {
        // do nothing, let the plugin clean itself up
    };
    AsyncViewHandler.prototype.attachCallback = function (view, prevState) {
        var _this = this;
        var promiseId = (this.inProgressPromise = Math.random());
        this.callback(view, prevState)
            .then(function (data) {
            // if another promise has been initialized before this one finished, cancel
            if (promiseId !== _this.inProgressPromise) {
                log("AsyncViewHandler attachCallback", "cancelling promise update due to another callback taking its place");
                return;
            }
            _this.inProgressPromise = null;
            // let the document know this callback has finished
            var trans = view.state.tr;
            _this.transactionKey.setCallbackData(trans, data);
            view.updateState(view.state.apply(trans));
        })
            // on error, don't dispatch, just clear
            .catch(function () {
            _this.inProgressPromise = null;
        });
    };
    return AsyncViewHandler;
}());
/**
 * Shortcut wrapper for a plugin with async functionality;
 * Overrides the spec's `view` property to manually handle async functionality
 */
var AsyncPlugin = /** @class */ (function (_super) {
    __extends(AsyncPlugin, _super);
    function AsyncPlugin(spec) {
        var _this = this;
        spec.view = function (view) {
            return new AsyncViewHandler(view, spec.key, spec.asyncCallback);
        };
        _this = _super.call(this, spec) || this;
        return _this;
    }
    /** @inheritdoc */
    AsyncPlugin.prototype.getMeta = function (tr) {
        var metadata = tr.getMeta(this.transactionKey);
        return metadata === null || metadata === void 0 ? void 0 : metadata.state;
    };
    AsyncPlugin.prototype.getCallbackData = function (tr) {
        var metadata = tr.getMeta(this.transactionKey);
        return metadata === null || metadata === void 0 ? void 0 : metadata.callbackData;
    };
    return AsyncPlugin;
}(StatefulPlugin));
export { AsyncPlugin };
