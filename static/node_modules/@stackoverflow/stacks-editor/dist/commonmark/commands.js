import { TextSelection, } from "prosemirror-state";
import { createMenuPlugin, makeMenuIcon, makeMenuLinkEntry, makeMenuSpacerEntry, addIf, } from "../shared/menu";
import { imageUploaderEnabled, showImageUploader, } from "../shared/prosemirror-plugins/image-upload";
import { undo, redo } from "prosemirror-history";
/**
 * Shortcut binding that takes in a formatting string and returns a matching setBlockType command
 * @param formattingText
 */
export var setBlockTypeCommand = function (formattingText) {
    return setBlockType.bind(null, formattingText);
};
/**
 * Shortcut binding that takes in a formatting string and returns a matching wrapIn command
 * @param formattingText
 */
export var wrapInCommand = function (formattingText) {
    return toggleWrapIn.bind(null, formattingText);
};
export var blockWrapInCommand = function (formattingText) {
    return toggleBlockWrap.bind(null, formattingText);
};
export var insertRawTextCommand = function (text, selectFrom, selectTo) {
    return insertRawText.bind(null, text, selectFrom, selectTo);
};
var newTextNode = function (schema, content) { return schema.text(content); };
/**
 * Toggles wrapping selected text in the formatting string; adds newly wrapped text if nothing is selected
 * @param formattingText The text to wrap the currently selected text in
 * @param state The current editor state
 * @param dispatch The dispatch function used to trigger the transaction, set to "null" if you don't want to dispatch
 */
function toggleWrapIn(formattingText, state, dispatch) {
    // check if we're unwrapping first
    if (unwrapIn(formattingText, state, dispatch)) {
        return true;
    }
    return wrapIn(formattingText, state, dispatch);
}
/**
 * Wraps the currently selected text with the passed text, creating new text if nothing is selected
 * @param formattingText The text to wrap the currently selected text in
 * @param state The current editor state
 * @param dispatch The dispatch function used to trigger the transaction, set to "null" if you don't want to dispatch
 */
function wrapIn(formattingText, state, dispatch) {
    var textToInsertOnEmptySelection = "your text";
    var _a = state.selection, from = _a.from, to = _a.to;
    var tr = state.tr.insertText(formattingText, to);
    if (state.selection.empty) {
        tr.insertText(textToInsertOnEmptySelection, to);
    }
    tr.insertText(formattingText, from).scrollIntoView();
    if (dispatch) {
        var selectionStart = from;
        // add the format length twice to adjust for the characters added before *and* after the text
        var selectionEnd = to + formattingText.length * 2;
        // if the selection was empty, just select the newly added text
        // and *not* the formatting so the user can start typing over it immediately
        if (state.selection.empty) {
            selectionStart = from + formattingText.length;
            selectionEnd = selectionStart + textToInsertOnEmptySelection.length;
        }
        // set the selection to include our newly added characters
        tr.setSelection(TextSelection.create(state.apply(tr).doc, selectionStart, selectionEnd));
        dispatch(tr);
    }
    return true;
}
/**
 * Unwraps the currently selected text if it is already wrapped in the passed text
 * @param formattingText The text to wrap the currently selected text in
 * @param state The current editor state
 * @param dispatch The dispatch function used to trigger the transaction, set to "null" if you don't want to dispatch
 */
function unwrapIn(formattingText, state, dispatch) {
    // if the selection is empty, then there is nothing to unwrap
    if (state.selection.empty) {
        return false;
    }
    var _a = state.selection, from = _a.from, to = _a.to;
    var selectedText = state.doc.textBetween(from, to);
    var precedingString = selectedText.slice(0, formattingText.length);
    var postcedingString = selectedText.slice(formattingText.length * -1);
    if (precedingString !== formattingText ||
        postcedingString !== formattingText) {
        return false;
    }
    if (dispatch) {
        var tr = state.tr;
        // unwrap the text and set into the document
        var unwrappedText = selectedText.slice(formattingText.length, formattingText.length * -1);
        tr.replaceSelectionWith(newTextNode(tr.doc.type.schema, unwrappedText));
        // set the selected text to the unwrapped text
        tr.setSelection(TextSelection.create(state.apply(tr).doc, from, to - formattingText.length * 2));
        dispatch(tr);
    }
    return true;
}
/**
 * Sets/unsets the block type of either selected (set for just the selection) or unselected (set at the beginning of the line) text
 * @param formattingText The text to prepend to the currently selected block
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function setBlockType(formattingText, state, dispatch) {
    // check first if we are toggling this entire block or toggling just the selected content
    if (setMultilineSelectedBlockType(formattingText, state, dispatch)) {
        return true;
    }
    return setSingleLineBlockType(formattingText, state, dispatch);
}
/**
 * Returns any block formatting characters (plus trailing space) at the very start of the passed text
 * @param text The text to check for leading block characters
 */
function matchLeadingBlockCharacters(text) {
    var _a;
    // TODO this might be too aggressive... remove based on a whitelist instead?
    // TODO HACK assumes all block types are non-letter characters followed by a single space
    return ((_a = /^[^a-zA-Z]+\s{1}(?=[a-zA-Z_*[!]|$)/.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) || "";
}
/**
 * Places/removes the passed text at the very beginning of the text block the selection exists in,
 * potentially removing other block text to do so
 * @param formattingText The text to prepend to the currently selected block
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function setSingleLineBlockType(formattingText, state, dispatch) {
    // get the "from" position of the cursor/selection only
    var from = state.selection.from;
    // get all text from the start of the doc to our cursor
    var textToCursor = state.doc.cut(0, from).textContent;
    // doc position is index differently (0 vs 1 indexed), so offset
    var stateOffset = 1;
    // look backwards for the most recent newline char
    var prevNewlineIndex = textToCursor.lastIndexOf("\n");
    // store where we're inserting our text; this will be our working point from now on
    var textInsertPos;
    // if there is no newline, set to beginning of doc
    if (prevNewlineIndex === -1) {
        textInsertPos = stateOffset;
    }
    else {
        // otherwise, set based on the index
        textInsertPos = prevNewlineIndex + stateOffset + "\n".length;
    }
    // always trail the formatting text with an empty space
    var trailingText = " ";
    // get all text starting from our insert point to check if we're toggling on/off
    var textFromInsert = state.doc.cut(textInsertPos).textContent;
    // check if *any* block type is already set
    var leadingBlockChars = matchLeadingBlockCharacters(textFromInsert);
    var tr = state.tr;
    if (leadingBlockChars.length) {
        // remove all leading block chars
        tr = tr.delete(textInsertPos, textInsertPos + leadingBlockChars.length);
    }
    var isTogglingOff = false;
    // check if the text at that index is already set to our formatting text
    if (leadingBlockChars === formattingText + trailingText) {
        isTogglingOff = true;
    }
    if (!isTogglingOff) {
        // add the formatting text
        tr = tr.insertText(formattingText + trailingText, textInsertPos);
    }
    if (dispatch) {
        tr = tr.scrollIntoView();
        dispatch(tr);
    }
    return true;
}
/**
 * Places/removes the passed text at the very beginning of each selected text line, creating a preceding newline if necessary
 * @param formattingText The text to prepend to the currently selected block
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function setMultilineSelectedBlockType(formattingText, state, dispatch) {
    // if the selection is empty, then this command is not valid
    if (state.selection.empty) {
        return false;
    }
    var from = state.selection.from;
    var selectedText = state.doc.cut(from, state.selection.to).textContent;
    // if there are no line breaks inside this text, then treat it as if we're editing the whole block
    if (!selectedText.includes("\n")) {
        return false;
    }
    // always trail the formatting text with a space
    var trailingText = " ";
    var tr = state.tr;
    // check the very first character on each line
    // if even a single line is missing, toggle all missing ON, else toggle all OFF
    var lines = selectedText.split("\n");
    var isTogglingOn = lines.some(function (text) { return !text.startsWith(formattingText + trailingText); });
    // doc position is index differently (0 vs 1 indexed), so offset
    var stateOffset = 1;
    var rangeFrom = from;
    lines.forEach(function (l) {
        var formattedLine;
        var leadingBlockChars = matchLeadingBlockCharacters(l);
        var beginsWithText = leadingBlockChars === formattingText + trailingText;
        if (isTogglingOn && beginsWithText) {
            // toggling on and already begins with text... leave it
            formattedLine = l;
        }
        else if (isTogglingOn && leadingBlockChars.length) {
            // toggling on and another block is there... replace
            formattedLine =
                formattingText +
                    trailingText +
                    l.slice(leadingBlockChars.length);
        }
        else if (isTogglingOn) {
            // toggling on and nothing is there... just add
            formattedLine = formattingText + trailingText + l;
        }
        else {
            // toggling off... remove whatever leading block chars are there
            formattedLine = l.slice(leadingBlockChars.length);
        }
        var rangeTo = rangeFrom + l.length;
        // we can't set an empty text node, so if the line is empty, just delete the text instead
        if (formattedLine.length) {
            tr = tr.replaceRangeWith(rangeFrom, rangeTo, newTextNode(tr.doc.type.schema, formattedLine));
        }
        else {
            tr = tr.deleteRange(rangeFrom, rangeTo);
        }
        // set the start of the next line to the altered line's length + 1 character for the removed (by .split) newline char
        rangeFrom += formattedLine.length + "\n".length;
    });
    // if the character immediately preceding the selection isn't a newline, add one
    if (from > stateOffset &&
        state.doc.textBetween(from - stateOffset, from) !== "\n") {
        tr = tr.insertText("\n", from, from);
        from += "\n".length;
        rangeFrom += "\n".length;
    }
    if (dispatch) {
        // the end of the selection is the calculated "rangeFrom", which includes all our added/removed chars
        // subtract a single \n's length from the end that is overadjusted in the calculation (for splitting on \n)
        var selectionEnd = rangeFrom - "\n".length;
        tr.setSelection(TextSelection.create(state.apply(tr).doc, from, selectionEnd));
        tr.scrollIntoView();
        dispatch(tr);
    }
    return true;
}
//TODO document
function toggleBlockWrap(formattingText, state, dispatch) {
    // check if we're unwrapping first
    if (blockUnwrapIn(formattingText, state, dispatch)) {
        return true;
    }
    return blockWrapIn(formattingText, state, dispatch);
}
/**
 * Wraps/unwraps a multiline block in the given formatting text, adding newlines before and after the selection if necessary
 * @param formattingText The text to wrap/unwrap the currently selected block in
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function blockWrapIn(formattingText, state, dispatch) {
    // empty selection, not valid
    if (state.selection.empty) {
        var placeholderText = "type here";
        var insertedBlock = "\n" + formattingText + "\n" + placeholderText + "\n" + formattingText + "\n";
        var newlineOffset = 2; // account for  two inserted newlines
        return insertRawText(insertedBlock, formattingText.length + newlineOffset, formattingText.length + placeholderText.length + newlineOffset, state, dispatch);
    }
    var _a = state.selection, from = _a.from, to = _a.to;
    // check if we need to unwrap
    if (blockUnwrapIn(formattingText, state, dispatch)) {
        return true;
    }
    // wrap the selected block in code fences, prepending/appending newlines if necessary
    var tr = state.tr;
    // if the character immediately preceding the selection isn't a newline, add one
    if (from > 0 && state.doc.textBetween(from - 1, from) !== "\n") {
        tr = tr.insertText("\n", from, from);
        from += 1;
        to += 1;
    }
    // if the character immediately postceding the selection isn't a newline, add one
    if (to + 1 < state.doc.content.size &&
        state.doc.textBetween(to, to + 1) !== "\n") {
        tr = tr.insertText("\n", to + 1, to + 1);
        to += 1;
    }
    // add this char before and after the selection along with the formatting text
    var surroundingChar = "\n";
    // insert the code fences from the end first so we don't mess up our from index
    tr.insertText(surroundingChar + formattingText, to);
    tr.insertText(formattingText + surroundingChar, from);
    if (dispatch) {
        // adjust our new text selection based on how many characters we added
        var addedTextModifier = surroundingChar.length + formattingText.length;
        tr.setSelection(TextSelection.create(state.apply(tr).doc, from, 
        // add modifier twice, once for added leading text, once for added trailing text
        to + addedTextModifier * 2));
        tr.scrollIntoView();
        dispatch(tr);
    }
    return true;
}
/**
 * Unwraps a multiline block in the given formatting text if able
 * @param formattingText The text to unwrap from currently selected block
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function blockUnwrapIn(formattingText, state, dispatch) {
    // no selection, not valid
    if (state.selection.empty) {
        return false;
    }
    var _a = state.selection, from = _a.from, to = _a.to;
    var selectedText = state.doc.textBetween(from, to);
    var surroundingChar = "\n";
    var totalFormattedLength = formattingText.length + surroundingChar.length;
    var precedingString = selectedText.slice(0, totalFormattedLength);
    var postcedingString = selectedText.slice(totalFormattedLength * -1);
    if (precedingString !== formattingText + surroundingChar ||
        postcedingString !== surroundingChar + formattingText) {
        return false;
    }
    var tr = state.tr;
    // remove our wrapping chars, starting with the trailing text so we don't disturb the from index
    tr = tr.delete(to - totalFormattedLength, to);
    tr = tr.delete(from, from + totalFormattedLength);
    if (dispatch) {
        tr.setSelection(TextSelection.create(state.apply(tr).doc, from, 
        // add modifier twice, once for added leading text, once for added trailing text
        to - totalFormattedLength * 2));
        tr.scrollIntoView();
        dispatch(tr);
    }
    return true;
}
/**
 * Inserts the given text at the cursor, replacing selected text if applicable
 * @param text The text to insert
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
function insertRawText(text, selectFrom, selectTo, state, dispatch) {
    var tr = state.tr;
    var from = state.selection.from;
    if (state.selection.empty) {
        tr = tr.insertText(text, from);
    }
    else {
        tr = tr.replaceSelectionWith(newTextNode(tr.doc.type.schema, text));
    }
    if (dispatch) {
        // if the select range is declared, select the specified range in the added text
        if (typeof selectFrom !== "undefined" &&
            typeof selectTo !== "undefined") {
            tr = tr.setSelection(TextSelection.create(state.apply(tr).doc, from + selectFrom, from + selectTo));
        }
        else {
            // if the range is NOT declared, set the cursor to before the inserted text
            tr = tr.setSelection(TextSelection.create(state.apply(tr).doc, from));
        }
        tr = tr.scrollIntoView();
        dispatch(tr);
    }
    return true;
}
/**
 * Inserts a link at the cursor, optionally placing it around the currenly selected text if able
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
export function insertLinkCommand(state, dispatch) {
    // TODO what dummy link to use?
    var dummyLink = "https://www.stackoverflow.com/";
    // TODO what should we select - text or link?
    if (state.selection.empty) {
        return insertRawText("[text](" + dummyLink + ")", 1, 5, state, dispatch);
    }
    var _a = state.selection, from = _a.from, to = _a.to;
    var selectedText = state.doc.textBetween(from, to);
    var insertedText = "[" + selectedText + "](" + dummyLink + ")";
    //TODO magic numbers!
    var selectFrom = 3 + selectedText.length;
    var selectTo = selectFrom + dummyLink.length;
    // insert the link with the link selected for easy typeover
    return insertRawText(insertedText, selectFrom, selectTo, state, dispatch);
}
/**
 * Inserts a basic table at the cursor
 * @param state The current editor state
 * @param dispatch the dispatch function used to dispatch the transaction, set to "null" if you don't want to dispatch
 */
export function insertTableCommand(state, dispatch) {
    var tableMarkdown = "\n| Column A | Column B |\n| -------- | -------- |\n| Cell 1   | Cell 2   |\n| Cell 3   | Cell 4   |\n";
    if (state.selection.empty) {
        return insertRawText(tableMarkdown, 1, 1, state, dispatch);
    }
}
//TODO
function indentBlockCommand() {
    return false;
}
//TODO
function unIndentBlockCommand() {
    return false;
}
export var boldCommand = wrapInCommand("**");
export var emphasisCommand = wrapInCommand("*");
export var inlineCodeCommand = wrapInCommand("`");
export var indentCommand = indentBlockCommand;
export var unindentBlock = unIndentBlockCommand;
export var headerCommand = setBlockTypeCommand("#");
export var strikethroughCommand = wrapInCommand("~~");
export var blockquoteCommand = setBlockTypeCommand(">");
export var orderedListCommand = setBlockTypeCommand("1.");
export var unorderedListCommand = setBlockTypeCommand("-");
export var insertHorizontalRuleCommand = insertRawTextCommand("\n---\n");
export var insertCodeblockCommand = blockWrapInCommand("```");
export function insertImageCommand(state, dispatch, view) {
    if (!imageUploaderEnabled(view)) {
        return false;
    }
    if (!dispatch)
        return true;
    showImageUploader(view);
    return true;
}
export var createMenu = function (options) {
    var _a;
    return createMenuPlugin([
        {
            key: "toggleHeading",
            command: headerCommand,
            dom: makeMenuIcon("Header", "Heading", "heading-btn"),
        },
        {
            key: "togglBold",
            command: boldCommand,
            dom: makeMenuIcon("Bold", "Bold", "bold-btn"),
        },
        {
            key: "toggleEmphasis",
            command: emphasisCommand,
            dom: makeMenuIcon("Italic", "Italic", "italic-btn"),
        },
        {
            key: "toggleCode",
            command: inlineCodeCommand,
            dom: makeMenuIcon("Code", "Inline code", "code-btn"),
        },
        addIf({
            key: "toggleStrikethrough",
            command: strikethroughCommand,
            dom: makeMenuIcon("Strikethrough", "Strikethrough", "strike-btn"),
        }, options.parserFeatures.extraEmphasis),
        makeMenuSpacerEntry(),
        {
            key: "toggleLink",
            command: insertLinkCommand,
            dom: makeMenuIcon("Link", "Insert link", "insert-link-btn"),
        },
        {
            key: "toggleBlockquote",
            command: blockquoteCommand,
            dom: makeMenuIcon("Quote", "Blockquote", "blockquote-btn"),
        },
        {
            key: "insertCodeblock",
            command: insertCodeblockCommand,
            dom: makeMenuIcon("Codeblock", "Insert code block", "code-block-btn"),
        },
        addIf({
            key: "insertImage",
            command: insertImageCommand,
            dom: makeMenuIcon("Image", "Insert image", "insert-image-btn"),
        }, !!((_a = options.imageUpload) === null || _a === void 0 ? void 0 : _a.handler)),
        addIf({
            key: "insertTable",
            command: insertTableCommand,
            dom: makeMenuIcon("Table", "Insert table", "insert-table-btn"),
        }, options.parserFeatures.tables),
        makeMenuSpacerEntry(),
        {
            key: "toggleOrderedList",
            command: orderedListCommand,
            dom: makeMenuIcon("OrderedList", "Numbered list", "numbered-list-btn"),
        },
        {
            key: "toggleUnorderedList",
            command: unorderedListCommand,
            dom: makeMenuIcon("UnorderedList", "Bulleted list", "bullet-list-btn"),
        },
        {
            key: "insertRule",
            command: insertHorizontalRuleCommand,
            dom: makeMenuIcon("HorizontalRule", "Insert Horizontal rule", "horizontal-rule-btn"),
        },
        makeMenuSpacerEntry(function () { return false; }, ["sm:d-inline-block"]),
        {
            key: "undo",
            command: undo,
            dom: makeMenuIcon("Undo", "Undo", "undo-btn", [
                "sm:d-inline-block",
            ]),
            visible: function () { return false; },
        },
        {
            key: "redo",
            command: redo,
            dom: makeMenuIcon("Refresh", "Redo", "redo-btn", [
                "sm:d-inline-block",
            ]),
            visible: function () { return false; },
        },
        makeMenuSpacerEntry(),
        //TODO eventually this will mimic the "help" dropdown in the prod editor
        makeMenuLinkEntry("Help", "Help", options.editorHelpLink),
    ], options.menuParentContainer);
};
