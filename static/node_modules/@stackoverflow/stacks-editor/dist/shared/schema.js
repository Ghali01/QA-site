var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { schema } from "prosemirror-markdown";
import { DOMParser, Schema, } from "prosemirror-model";
import { escapeHTML } from "./utils";
//TODO this relies on Stacks classes, should we abstract?
/**
 * Defines an uneditable html_block node; Only appears when a user has written a "complicated" html_block
 * i.e. anything not resembling `<tag>content</tag>` or `<tag />`
 */
var htmlBlockSpec = {
    content: "text*",
    attrs: { content: { default: "" } },
    marks: "_",
    group: "block",
    atom: true,
    inline: false,
    selectable: true,
    // IMPORTANT! Removing this will cause inline content to be "collapsed" upwards, removing the metadata
    defining: true,
    // isolating set true so we don't allow outside content to accidentally enter this node (preserves html inside)
    isolating: true,
    parseDOM: [{ tag: "div.html_block" }],
    toDOM: function (node) {
        return [
            "div",
            {
                class: "html_block",
            },
            node.attrs.content,
        ];
    },
};
/**
 * Defines an uneditable html_inline node; These should very rarely appear in cases where
 * a user has a "valid", but unpaired html_inline tag (e.g. `test</em>`)
 */
var htmlInlineSpec = {
    content: "text*",
    attrs: { content: { default: "" } },
    marks: "_",
    group: "inline",
    atom: true,
    inline: true,
    selectable: true,
    // IMPORTANT! Removing this will cause inline content to be "collapsed" upwards, removing the metadata
    defining: true,
    // isolating set true so we don't allow outside content to accidentally enter this node (preserves html inside)
    isolating: true,
    parseDOM: [{ tag: "span.html_inline" }],
    toDOM: function (node) {
        return [
            "span",
            {
                class: "html_inline",
            },
            node.attrs.content,
        ];
    },
};
/**
 * Represents an `html_block` node that was split by a newline, then put back together post-tokenization.
 * The "content" of the container is editable, but the leading/trailing html is not.
 * e.g `<blockquote>**Test**\n\n_test_</blockquote>` will have the `_test_` editable, but not the `**Test**`
 */
var htmlBlockContainerSpec = {
    content: "block*",
    attrs: { contentOpen: { default: "" }, contentClose: { default: "" } },
    marks: "_",
    group: "block",
    inline: false,
    selectable: true,
    // IMPORTANT! Removing this will cause inline content to be "collapsed" upwards, removing the metadata
    defining: true,
    // isolating set true so we don't allow outside content to accidentally enter this node (preserves html inside)
    isolating: true,
};
// manually render softbreaks, making sure to mark them
// so we when parse them back out we can convert back to \n for markdown
var softbreakSpec = {
    content: "inline+",
    attrs: {},
    marks: "_",
    inline: true,
    group: "inline",
    // TODO accurate? necessary?
    parseDOM: [
        {
            tag: "span[softbreak]",
            getAttrs: function (node) {
                return {
                    content: node.innerHTML,
                };
            },
        },
    ],
    toDOM: function () {
        return [
            "span",
            {
                softbreak: "",
            },
            0,
        ];
    },
};
var spoilerNodeSpec = {
    content: "block+",
    group: "block",
    attrs: { revealed: { default: false } },
    parseDOM: [
        {
            tag: "blockquote.spoiler",
            getAttrs: function (node) {
                return {
                    revealed: node.classList.contains("is-visible"),
                };
            },
        },
    ],
    toDOM: function (node) {
        return [
            "blockquote",
            {
                "class": "spoiler" + (node.attrs.revealed ? " is-visible" : ""),
                // TODO localization
                "data-spoiler": "Reveal spoiler",
            },
            0,
        ];
    },
};
/**
 * Creates a generic html NodeSpec for a block html tag
 * @param tag The name of the tag to use in the Prosemirror dom
 */
function genHtmlBlockNodeSpec(tag) {
    return {
        content: "block+",
        marks: "",
        group: "block",
        inline: false,
        selectable: true,
        toDOM: function () {
            return [tag, 0];
        },
        parseDOM: [{ tag: tag }],
    };
}
var defaultNodes = schema.spec.nodes;
var extendedImageSpec = __assign(__assign({}, defaultNodes.get("image")), {
    attrs: {
        src: {},
        alt: { default: null },
        title: { default: null },
        width: { default: null },
        height: { default: null },
    },
    parseDOM: [
        {
            tag: "img[src]",
            getAttrs: function (dom) {
                return {
                    src: dom.getAttribute("src"),
                    title: dom.getAttribute("title"),
                    alt: dom.getAttribute("alt"),
                    height: dom.getAttribute("height"),
                    width: dom.getAttribute("width"),
                };
            },
        },
    ],
    toDOM: function (node) {
        return ["img", node.attrs];
    },
});
var extendedCodeblockSpec = __assign(__assign({}, defaultNodes.get("code_block")), {
    attrs: {
        params: { default: "" },
        detectedHighlightLanguage: { default: "" },
    },
});
var tableNodeSpec = {
    content: "table_head table_body*",
    isolating: true,
    group: "block",
    selectable: false,
    parseDOM: [{ tag: "table" }],
    toDOM: function () {
        return [
            "div",
            { class: "s-table-container" },
            ["table", { class: "s-table" }, 0],
        ];
    },
};
var tableHeadNodeSpec = {
    content: "table_row",
    isolating: true,
    group: "table_block",
    selectable: false,
    parseDOM: [{ tag: "thead" }],
    toDOM: function () {
        return ["thead", 0];
    },
};
var tableBodyNodeSpec = {
    content: "table_row+",
    isolating: true,
    group: "table_block",
    selectable: false,
    parseDOM: [{ tag: "tbody" }],
    toDOM: function () {
        return ["tbody", 0];
    },
};
var tableRowNodeSpec = {
    content: "(table_cell | table_header)+",
    isolating: true,
    group: "table_block",
    selectable: false,
    parseDOM: [{ tag: "tr" }],
    toDOM: function () {
        return ["tr", 0];
    },
};
var tableCellNodeSpec = {
    content: "inline*",
    isolating: true,
    group: "table_block",
    selectable: false,
    attrs: {
        style: { default: null },
    },
    parseDOM: [
        {
            tag: "td",
            getAttrs: function (dom) {
                var textAlign = dom.style.textAlign;
                return textAlign ? { style: "text-align: " + textAlign } : null;
            },
        },
    ],
    toDOM: function (node) {
        return ["td", node.attrs, 0];
    },
};
var tableHeaderNodeSpec = {
    content: "inline*",
    isolating: true,
    group: "table_block",
    selectable: false,
    attrs: {
        style: { default: null },
    },
    parseDOM: [
        {
            tag: "th",
            getAttrs: function (dom) {
                var textAlign = dom.style.textAlign;
                return textAlign ? { style: "text-align: " + textAlign } : null;
            },
        },
    ],
    toDOM: function (node) {
        return ["th", node.attrs, 0];
    },
};
// TODO should this be a mark instead?
var tagLinkNodeSpec = {
    content: "text*",
    marks: "",
    atom: true,
    inline: true,
    group: "inline",
    attrs: {
        tagName: { default: null },
        tagType: { default: "tag" },
    },
};
var nodes = defaultNodes
    .addBefore("image", "pre", genHtmlBlockNodeSpec("pre"))
    .addBefore("image", "html_block", htmlBlockSpec)
    .addBefore("image", "html_inline", htmlInlineSpec)
    .addBefore("image", "html_block_container", htmlBlockContainerSpec)
    .addBefore("image", "softbreak", softbreakSpec)
    .addBefore("image", "table", tableNodeSpec)
    .addBefore("image", "table_head", tableHeadNodeSpec)
    .addBefore("image", "table_body", tableBodyNodeSpec)
    .addBefore("image", "table_row", tableRowNodeSpec)
    .addBefore("image", "table_cell", tableCellNodeSpec)
    .addBefore("image", "table_header", tableHeaderNodeSpec)
    .addBefore("image", "tagLink", tagLinkNodeSpec)
    .addBefore("blockquote", "spoiler", spoilerNodeSpec)
    .update("image", extendedImageSpec)
    .update("code_block", extendedCodeblockSpec);
/**
 * Creates a generic html MarkSpec for an inline html tag
 * @param tag The name of the tag to use in the Prosemirror dom
 */
function genHtmlInlineMarkSpec() {
    var tags = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tags[_i] = arguments[_i];
    }
    return {
        toDOM: function () {
            return [tags[0], 0];
        },
        parseDOM: tags.map(function (tag) { return ({ tag: tag }); }),
    };
}
var defaultMarks = schema.spec.marks;
var extendedLinkMark = __assign(__assign({}, defaultMarks.get("link")), {
    toDOM: function (node) {
        return [
            "a",
            {
                href: node.attrs.href,
                title: node.attrs.title,
            },
        ];
    },
});
var marks = defaultMarks
    .addBefore("strong", "strike", genHtmlInlineMarkSpec("del", "s", "strike"))
    .addBefore("strong", "kbd", genHtmlInlineMarkSpec("kbd"))
    .addBefore("strong", "sup", genHtmlInlineMarkSpec("sup"))
    .addBefore("strong", "sub", genHtmlInlineMarkSpec("sub"))
    .update("link", extendedLinkMark);
// for *every* mark, add in support for the `markup` attribute
// we use this to save the "original" html tag used to create the mark when converting from html markdown
// this is important because a user could use either `<b>` or `<strong>` to create bold, and we want to preserve this when converting back
marks.forEach(function (k, node) {
    var attrs = node.attrs || {};
    attrs.markup = { default: "" };
    node.attrs = attrs;
});
// ditto for nodes
nodes.forEach(function (k, node) {
    if (k === "text") {
        return;
    }
    var attrs = node.attrs || {};
    attrs.markup = { default: "" };
    node.attrs = attrs;
});
// create our new, final schema using the extended nodes/marks taken from `schema`
export var richTextSchema = new Schema({
    nodes: nodes,
    marks: marks,
});
export var tableNodes = [
    richTextSchema.nodes.table,
    richTextSchema.nodes.table_head,
    richTextSchema.nodes.table_body,
    richTextSchema.nodes.table_row,
    richTextSchema.nodes.table_cell,
    richTextSchema.nodes.table_header,
];
// create a modified schema for commonmark
export var commonmarkSchema = new Schema({
    nodes: {
        doc: {
            content: "code_block+",
        },
        text: {
            group: "inline",
        },
        code_block: {
            content: "text*",
            group: "block",
            marks: "",
            code: true,
            defining: true,
            isolating: true,
            // don't let the user select / delete with (ctrl+a)
            selectable: false,
            // force the block language to always be markdown
            attrs: { params: { default: "markdown" } },
            parseDOM: [
                {
                    tag: "pre",
                    preserveWhitespace: "full",
                },
            ],
            toDOM: function () {
                return ["pre", { class: "s-code-block markdown" }, ["code", 0]];
            },
        },
    },
    marks: {},
});
/** Parses out a Prosemirror document from a code (markdown) string */
var CodeStringParser = /** @class */ (function (_super) {
    __extends(CodeStringParser, _super);
    function CodeStringParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CodeStringParser.prototype.parseCode = function (content, options) {
        var node = document.createElement("div");
        node.innerHTML = escapeHTML(templateObject_1 || (templateObject_1 = __makeTemplateObject(["<pre>", "</pre>"], ["<pre>", "</pre>"])), content);
        return _super.prototype.parse.call(this, node, options);
    };
    CodeStringParser.fromSchema = function (schema) {
        return (schema.cached.domParser ||
            (schema.cached.domParser = new CodeStringParser(schema, CodeStringParser.schemaRules(schema))));
    };
    CodeStringParser.toString = function (node) {
        return node.textBetween(0, node.content.size, "\n\n");
    };
    return CodeStringParser;
}(DOMParser));
export { CodeStringParser };
var templateObject_1;
