import { ContentMatch, NodeType } from "prosemirror-model";
import { deepMerge } from "./utils";
/**
 * Sets the `contentMatch` property of a node to match the current schema
 */
function setContentMatch(nodeType, schema) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    nodeType.contentMatch = ContentMatch.parse(nodeType.spec.content || "", schema.nodes);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    nodeType.inlineContent = nodeType.contentMatch.inlineContent;
}
/**
 * Collapses a collection of ExternalEditorPlugin down into a single plugin
 * @param plugins The plugins to collapse
 */
export function collapseExternalPlugins(plugins) {
    plugins = plugins || [];
    var collapsed = plugins.reduce(function (prev, next) {
        if (!prev) {
            return next;
        }
        return deepMerge(prev, next);
    }, null);
    var emptyPlugin = {
        menuEntries: [],
        nodeViews: {},
        markdownParser: {
            tokens: {},
            plugins: [],
        },
        markdownSerializers: {},
        plugins: [],
        schema: null,
    };
    return collapsed || emptyPlugin;
}
/**
 * Alters an existing schema by combining it with a new schema;
 * avoids creating a new schema altogether so other plugins referencing the base schema don't fail
 * @param schema The base schema to alter / add to
 * @param pluginSchema The schema from an ExternalEditorPlugin to add into the base schema
 */
export function combineSchemas(schema, pluginSchema) {
    if (!pluginSchema) {
        return schema;
    }
    Object.keys(pluginSchema.nodes).forEach(function (n) {
        if (schema.nodes[n]) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        var nodeType = new NodeType(n, schema, pluginSchema.nodes[n]);
        setContentMatch(nodeType, schema);
        schema.nodes[n] = nodeType;
    });
    Object.keys(schema.nodes).forEach(function (n) {
        setContentMatch(schema.nodes[n], schema);
    });
    return schema;
}
