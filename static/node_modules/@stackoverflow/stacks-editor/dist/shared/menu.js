var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { Plugin } from "prosemirror-state";
import { docChanged } from "./utils";
/** NoOp to use in place of missing commands */
var commandNoOp = function () { return false; };
var MenuView = /** @class */ (function () {
    function MenuView(items, view) {
        var _a;
        var _this = this;
        this.items = items;
        this.view = view;
        // turn all menu commands into a flat list so we can easily look them up later
        this.menuCommands = (_a = []).concat.apply(_a, this.items.map(function (item) {
            if (item.children) {
                // include the drop-down parent AND all of its children if there are child MenuCommandEntries
                return __spreadArray([item], item.children);
            }
            return item;
        }));
        this.dom = document.createElement("div");
        this.dom.className =
            "d-flex gs2 mln4 fl-grow1 ai-center js-editor-menu";
        this.items.forEach(function (_a) {
            var dom = _a.dom;
            return _this.dom.appendChild(dom);
        });
        this.update(view, null);
        // NOTE: make sure your plugin/menu container calls `e.preventDefault()` on `mousedown` events
        // so the editor doesn't blur on click! StacksEditor automatically handles this for us in a typical use-case
        var menuCommands = this.menuCommands;
        this.dom.addEventListener("click", function (e) {
            // find the closest button parent of the clicked element
            var target = e.target.closest(".js-editor-btn");
            if (!target) {
                return;
            }
            // if the button is "disabled", return early
            if (target.classList.contains(MenuView.disabledClass)) {
                return;
            }
            var key = target.dataset.key;
            e.preventDefault();
            view.focus();
            var found = menuCommands.find(function (c) { return c.key === key; });
            if (found) {
                found.command(view.state, view.dispatch.bind(view), view);
            }
        });
        this.readonly = !view.editable;
    }
    MenuView.prototype.update = function (view, prevState) {
        var _this = this;
        // if the doc/view hasn't changed, there's no work to do
        if (!docChanged(prevState, view.state) &&
            this.readonly !== view.editable) {
            return;
        }
        this.readonly = !view.editable;
        // disable *all* clicks if the menu is readonly
        this.dom.classList.toggle("pe-none", this.readonly);
        var viewIsReadonly = this.readonly;
        var activeClass = "is-selected";
        var invisibleClass = "d-none";
        var disabledClass = MenuView.disabledClass;
        this.menuCommands.forEach(function (entry) {
            var dom = entry.dom;
            // make sure we really got the button itself, not a wrapper
            if (!dom.classList.contains("js-editor-btn")) {
                var button = dom.querySelector(".js-editor-btn");
                dom = button !== null && button !== void 0 ? button : dom;
            }
            var isFocused = _this.view.hasFocus();
            var visible = entry.visible
                ? entry.visible(_this.view.state)
                : true;
            var active = isFocused && entry.active
                ? entry.active(_this.view.state)
                : false;
            var enabled = !viewIsReadonly &&
                entry.command(_this.view.state, undefined, _this.view);
            dom.classList.remove(disabledClass);
            dom.classList.remove(activeClass);
            dom.classList.remove(invisibleClass);
            dom.dataset.key = entry.key;
            // class priority is active > disabled > default
            if (!visible) {
                dom.classList.add(invisibleClass);
            }
            else if (active) {
                dom.classList.add(activeClass);
            }
            else if (!enabled) {
                dom.classList.add(disabledClass);
            }
        });
    };
    MenuView.prototype.destroy = function () {
        this.dom.remove();
    };
    MenuView.disabledClass = "is-disabled";
    return MenuView;
}());
/**
 * Simple wrapper function to ensure that conditional menu item adds are consistent
 * @param item The item to add if flag is truty
 * @param flag Whether to add the item
 */
export function addIf(item, flag) {
    return flag ? item : null;
}
/**
 * Creates a menu plugin with the passed in entries
 * @param items The entries to use on the generated menu
 */
export function createMenuPlugin(items, containerFn) {
    // remove all empty / falsy items
    var validItems = items.filter(function (i) { return !!i; });
    return new Plugin({
        view: function (editorView) {
            var menuView = new MenuView(validItems, editorView);
            containerFn =
                containerFn ||
                    function (v) {
                        return v.dom.parentNode;
                    };
            var container = containerFn(editorView);
            // if the container is the same as the one that has the editor
            // insert the menu before it
            if (container.contains(editorView.dom)) {
                container.insertBefore(menuView.dom, editorView.dom);
            }
            else {
                container.insertBefore(menuView.dom, container.firstChild);
            }
            return menuView;
        },
    });
}
/**
 * Helper function to create consistent menu entry doms
 * @param iconName The html of the svg to use as the icon
 * @param title The text to place in the button's title attribute
 * @param key A unique identifier used for identifying the command to be executed on click
 * @param cssClasses extra CSS classes to be applied to this menu icon (optional)
 */
export function makeMenuIcon(iconName, title, key, cssClasses) {
    var _a;
    var button = document.createElement("button");
    button.className = "s-editor-btn flex--item js-editor-btn js-" + key;
    if (cssClasses) {
        (_a = button.classList).add.apply(_a, cssClasses);
    }
    button.title = title;
    button.dataset.controller = "s-tooltip";
    button.dataset.sTooltipPlacement = "top";
    button.dataset.key = key;
    button.type = "button";
    // create the svg icon-bg element
    var icon = document.createElement("span");
    icon.className = "icon-bg icon" + iconName;
    button.append(icon);
    return button;
}
/**
 * Helper function to create a MenuCommandEntry for a menu spacer
 */
export function makeMenuSpacerEntry(visible, cssClasses) {
    var _a;
    var dom = document.createElement("div");
    dom.className = "flex--item w16";
    if (cssClasses) {
        (_a = dom.classList).add.apply(_a, cssClasses);
    }
    return {
        key: "spacer",
        command: commandNoOp,
        active: commandNoOp,
        visible: visible,
        dom: dom,
    };
}
/**
 * Create a dropdown menu item that contains all children in its popover
 * @param svg The html of the svg to use as the dropdown icon
 * @param title The text to place in the dropdown button's title attribute
 * @param key A unique identifier used for this dropdown menu
 * @param visible A function that determines wether the dropdown should be visible or hidden
 * @param children The child MenuComandEntry items to be placed in the dropdown menu
 */
export function makeMenuDropdown(svg, title, key, visible) {
    var children = [];
    for (var _i = 4; _i < arguments.length; _i++) {
        children[_i - 4] = arguments[_i];
    }
    var popoverId = "table-button-popover";
    var button = makeMenuIcon(svg, title, key);
    button.classList.add("s-btn", "s-btn__dropdown");
    button.setAttribute("aria-controls", popoverId);
    button.setAttribute("data-controller", "s-popover");
    button.setAttribute("data-action", "s-popover#toggle");
    button.setAttribute("data-s-popover-toggle-class", "is-selected");
    button.dataset.key = key;
    var popover = document.createElement("div");
    popover.className = "s-popover wmn-initial w-auto px0 pt0 pb8";
    popover.id = popoverId;
    popover.setAttribute("role", "menu");
    var arrow = document.createElement("div");
    arrow.className = "s-popover--arrow";
    popover.appendChild(arrow);
    var content = document.createElement("div");
    content.className = "d-flex fd-column";
    content.append.apply(content, children.map(function (c) { return c.dom; }));
    popover.appendChild(content);
    var wrapper = document.createElement("div");
    wrapper.appendChild(button);
    wrapper.appendChild(popover);
    return {
        key: key,
        dom: wrapper,
        children: children,
        command: function () { return true; },
        visible: visible,
    };
}
/**
 * Creates a dropdown menu item that can be embedded in a dropdown menu's popover
 * @param title The text to be displayed for this item
 * @param command The command to be executed when this item is clicked
 * @param key A unique identifier used for identifying the command to be executed on click
 */
export function dropdownItem(title, command, key) {
    var button = document.createElement("button");
    button.type = "button";
    button.className = "s-btn s-btn__unset flex--item ta-left px12 py4 h:bg-black-050 c-pointer js-editor-btn";
    button.dataset.key = key;
    button.textContent = title;
    return {
        key: key,
        command: command,
        dom: button,
    };
}
/**
 * Creates a section with a heading usable for dropdown menus. This is just a visual element with no
 * interaction and no action being triggered on click
 * @param title The text to be displayed for this item
 * @param key A unique identifier used for identifying the command to be executed on click
 */
export function dropdownSection(title, key) {
    var section = document.createElement("span");
    section.className = "flex--item ta-left fs-fine tt-uppercase mx12 mb6 mt12 fc-black-400";
    section.dataset.key = key;
    section.textContent = title;
    return {
        key: key,
        command: function () { return true; },
        visible: function () { return true; },
        active: function () { return false; },
        dom: section,
    };
}
/**
 * Creates a link entry that opens a _blank to href when clicked
 * @param iconName The html of the svg to use as the icon
 * @param title The text to place in the link's title attribute
 * @param href The href to open when clicked
 */
export function makeMenuLinkEntry(iconName, title, href) {
    var dom = document.createElement("a");
    dom.className = "s-editor-btn js-editor-btn flex--item";
    dom.href = href;
    dom.target = "_blank";
    dom.title = title;
    dom.dataset.controller = "s-tooltip";
    dom.dataset.sTooltipPlacement = "top";
    // create the svg icon-bg element
    var icon = document.createElement("span");
    icon.className = "icon-bg icon" + iconName;
    dom.append(icon);
    return {
        key: title,
        command: function (_, dispatch) {
            if (dispatch) {
                window.open(dom.href, dom.target);
            }
            return !!href;
        },
        active: commandNoOp,
        dom: dom,
    };
}
