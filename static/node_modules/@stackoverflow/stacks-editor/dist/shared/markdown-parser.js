var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import MarkdownIt from "markdown-it/lib";
import { defaultMarkdownParser, MarkdownParser, } from "prosemirror-markdown";
import { log } from "./logger";
import { html } from "./markdown-it/html";
import { spoiler } from "./markdown-it/spoiler";
import { stackLanguageComments } from "./markdown-it/stack-language-comments";
import { tagLinks } from "./markdown-it/tag-link";
import { tight_list } from "./markdown-it/tight-list";
import { validateLink } from "./utils";
// extend the default markdown parser's tokens and add our own
var customMarkdownParserTokens = __assign(__assign({}, defaultMarkdownParser.tokens), {
    pre: { block: "pre" },
    kbd: { mark: "kbd" },
    sup: { mark: "sup" },
    sub: { mark: "sub" },
    html_inline: {
        node: "html_inline",
        getAttrs: function (token) { return ({
            content: token.content,
        }); },
    },
    html_block: {
        node: "html_block",
        getAttrs: function (token) { return ({
            content: token.content,
        }); },
    },
    html_block_container: {
        block: "html_block_container",
        getAttrs: function (token) { return ({
            contentOpen: token.attrGet("contentOpen"),
            contentClose: token.attrGet("contentClose"),
        }); },
    },
    // don't map our intermediary "stack_language*_comment" tokens. These are stripped from the stream, so they shouldn't be coming back anyways
    stack_language_comment: { ignore: true },
    stack_language_all_comment: { ignore: true },
    bullet_list: {
        block: "bullet_list",
        getAttrs: function (tok) { return ({
            tight: tok.attrGet("tight") === "true",
        }); },
    },
    ordered_list: {
        block: "ordered_list",
        getAttrs: function (tok) { return ({
            order: +tok.attrGet("start") || 1,
            tight: tok.attrGet("tight") === "true",
        }); },
    },
    code_block: {
        block: "code_block",
        getAttrs: function (tok) { return ({ params: tok.info || "" }); },
    },
    // add support for the strike mark
    s: {
        mark: "strike",
    },
    table: {
        block: "table",
    },
    thead: {
        block: "table_head",
    },
    tbody: {
        block: "table_body",
    },
    th: {
        block: "table_header",
        getAttrs: function (tok) { return ({
            style: tok.attrGet("style"),
        }); },
    },
    tr: {
        block: "table_row",
    },
    td: {
        block: "table_cell",
        getAttrs: function (tok) { return ({
            style: tok.attrGet("style"),
        }); },
    },
    // override the default image parser so we can add our own extended attributes
    image: {
        node: "image",
        getAttrs: function (tok) {
            var _a, _b;
            return ({
                src: tok.attrGet("src"),
                width: tok.attrGet("width"),
                height: tok.attrGet("height"),
                alt: tok.attrGet("alt") || ((_b = (_a = tok.children) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) || null,
                title: tok.attrGet("title"),
            });
        },
    },
    tag_link: {
        block: "tagLink",
        getAttrs: function (tok) { return ({
            tagName: tok.attrGet("tagName"),
            tagType: tok.attrGet("tagType"),
        }); },
    },
    spoiler: {
        block: "spoiler",
    },
    // support <code>foo</code> which parses differently from `bar`
    code_inline_split: {
        mark: "code",
    },
});
// add tag attribute support to all the marks like we did in schema
// this allows us to map the original tags to / from markdown
Object.keys(customMarkdownParserTokens).forEach(function (k) {
    var token = customMarkdownParserTokens[k];
    // if an existing getAttrs function exists, make sure we wrap it and add our attributes in
    if (token.getAttrs) {
        var origGetAttrs_1 = token.getAttrs.bind(token);
        token.getAttrs = function (tok) {
            var attrs = origGetAttrs_1(tok);
            attrs.markup = tok.markup;
            return attrs;
        };
        return;
    }
    // set a getAttrs function that returns the tag attribute
    token.getAttrs = function (tok) { return ({
        markup: tok.markup,
    }); };
});
// TODO can we do this more cleanly?
/**
 * Custom MardownParser that manually adds a low-level handler for `html_inline`.
 * We do this because we need some special functionality that is not exposed by default with the existing
 * handler generation code (from adding tokens)
 */
var SOMarkdownParser = /** @class */ (function (_super) {
    __extends(SOMarkdownParser, _super);
    function SOMarkdownParser(schema, tokenizer, tokens) {
        var _this = _super.call(this, schema, tokenizer, tokens) || this;
        // prosemirror visually preserves the \n from a softbreak (whitespace: pre-wrap),
        // so replace with " " (space) to be commonmark compliant
        _this.tokenHandlers.softbreak = function (state) {
            var nodeType = _this.schema.nodes["softbreak"];
            state.openNode(nodeType, {});
            state.addText(" ");
            state.closeNode();
        };
        return _this;
    }
    return SOMarkdownParser;
}(MarkdownParser));
/**
 * Extended MarkdownIt so we can peek into the tokens during parse
 * TODO we can likely remove this extended version now that we've moved internal items to plugins
 */
var SOMarkdownIt = /** @class */ (function (_super) {
    __extends(SOMarkdownIt, _super);
    function SOMarkdownIt(presetName, options) {
        return _super.call(this, presetName, options) || this;
    }
    SOMarkdownIt.prototype.parse = function (src, env) {
        var parsed = _super.prototype.parse.call(this, src, env);
        log("Sanitized markdown token tree", parsed);
        return parsed;
    };
    return SOMarkdownIt;
}(MarkdownIt));
/**
 * Builds a custom markdown parser with the passed features toggled
 * @param features The features to toggle on/off
 */
export function buildMarkdownParser(features, schema, externalPlugins) {
    var _a;
    if (!features) {
        throw "Cannot build markdown parser without passed features.";
    }
    var defaultMarkdownItInstance = new SOMarkdownIt("default", {
        html: features.html,
        linkify: true, // automatically link plain URLs
    });
    if (!features.tables) {
        defaultMarkdownItInstance.disable("table");
    }
    // match features to Markdig's extra emphasis plugin
    // https://github.com/lunet-io/markdig/blob/master/src/Markdig.Tests/Specs/EmphasisExtraSpecs.md
    if (!features.extraEmphasis) {
        defaultMarkdownItInstance.disable("strikethrough");
    }
    // disable autolinking of anything that comes without protocol prefix (e.g. https://)
    defaultMarkdownItInstance.linkify.set({ fuzzyLink: false });
    // use a custom link validator that's closer to Stack Overflow's backend validation
    defaultMarkdownItInstance.validateLink = validateLink;
    // start adding in the parser plugins, NOTE: order matters!
    // parse/sanitize html
    if (features.html) {
        defaultMarkdownItInstance.use(function (md) { return html(md); });
    }
    // map language html comments to code blocks like code fences
    defaultMarkdownItInstance.use(stackLanguageComments);
    // parse tag links
    if (features.tagLinks) {
        defaultMarkdownItInstance.use(tagLinks, features.tagLinks);
    }
    // parse spoilers
    defaultMarkdownItInstance.use(spoiler);
    // ensure lists are tighted up for parsing into the doc
    defaultMarkdownItInstance.use(tight_list);
    if (externalPlugins === null || externalPlugins === void 0 ? void 0 : externalPlugins.markdownParser) {
        externalPlugins.markdownParser.plugins.forEach(function (p) {
            defaultMarkdownItInstance.use(p);
        });
    }
    return new SOMarkdownParser(schema, defaultMarkdownItInstance, __assign(__assign({}, customMarkdownParserTokens), (_a = externalPlugins === null || externalPlugins === void 0 ? void 0 : externalPlugins.markdownParser) === null || _a === void 0 ? void 0 : _a.tokens));
}
