var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { defaultMarkdownSerializer, MarkdownSerializer, } from "prosemirror-markdown";
import { richTextSchema } from "../shared/schema";
import { error } from "../shared/logger";
// TODO There's no way to sanely override these without completely rewriting them
// TODO Should contribute this back upstream and remove
var defaultMarkdownSerializerNodes = __assign(__assign({}, defaultMarkdownSerializer.nodes), { blockquote: function (state, node) {
        // TODO markup could be html
        var markup = node.attrs.markup || ">";
        state.wrapBlock(markup + " ", null, node, function () {
            return state.renderContent(node);
        });
    }, code_block: function (state, node) {
        // TODO could be html...
        var markup = node.attrs.markup;
        // lack of a markup indicator means this is an indented code block
        if (!markup) {
            var lines = node.textContent.split("\n");
            lines.forEach(function (l, i) {
                if (i > 0) {
                    state.ensureNewLine();
                }
                state.text("    " + l, false);
            });
        }
        else {
            state.write(markup + (node.attrs.params || "") + "\n");
            state.text(node.textContent, false);
            state.ensureNewLine();
            state.write(markup);
        }
        state.closeBlock(node);
    }, heading: function (state, node) {
        var markup = node.attrs.markup || "";
        if (markup.startsWith("<")) {
            // TODO html
            state.write("h1 tag TODO");
            state.closeBlock(node);
        }
        else if (markup && !markup.startsWith("#")) {
            // "underlined" heading (Setext heading)
            state.renderInline(node);
            state.ensureNewLine();
            state.write(markup); //TODO write once or write the entire length of the text?
            state.closeBlock(node);
        }
        else {
            // markup is # (ATX heading) or empty
            state.write(state.repeat("#", node.attrs.level) + " ");
            state.renderInline(node);
            state.closeBlock(node);
        }
    }, horizontal_rule: function (state, node) {
        // TODO could be html
        state.write(node.attrs.markup || "----------");
        state.closeBlock(node);
    }, bullet_list: function (state, node) {
        var markup = node.attrs.markup || "-";
        state.renderList(node, "  ", function () { return markup + " "; });
    }, ordered_list: function (state, node) {
        // TODO could be html
        var start = node.attrs.order || 1;
        var maxW = String(start + node.childCount - 1).length;
        var space = state.repeat(" ", maxW + 2);
        var markup = node.attrs.markup || ".";
        state.renderList(node, space, function (i) {
            var nStr = String(start + i);
            return state.repeat(" ", maxW - nStr.length) + nStr + markup + " ";
        });
    }, list_item: function (state, node) {
        // TODO could be html
        state.renderContent(node);
    }, paragraph: function (state, node) {
        // TODO could be html
        state.renderInline(node);
        state.closeBlock(node);
    }, image: function (state, node) {
        // TODO could be html
        state.write("![" +
            state.esc(node.attrs.alt || "") +
            "](" +
            state.esc(node.attrs.src) +
            (node.attrs.title ? " " + state.quote(node.attrs.title) : "") +
            ")");
    }, hard_break: function (state, node, parent, index) {
        // TODO could be html, `[space][space][newline]` or `\[newline]`
        // TODO markdown-it's output doesn't differentiate in the later two cases, so assume spacespace since that is likely more common
        for (var i = index + 1; i < parent.childCount; i++)
            if (parent.child(i).type != node.type) {
                state.write("  \n");
                return;
            }
    }, text: function (state, node) {
        var linkMark = node.marks.find(function (m) { return m.type.name === "link"; });
        var text = node.text;
        // if the text node is from a link, use the original href text if the original markup used it
        if (["linkify", "autolink"].includes(linkMark === null || linkMark === void 0 ? void 0 : linkMark.attrs.markup)) {
            text = linkMark.attrs.href;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
        var startOfLine = state.atBlank() || state.closed;
        // escape the text using the built in escape code
        var escapedText = state.esc(text, startOfLine);
        // built in escape doesn't get all the cases TODO upstream!
        escapedText = escapedText.replace(/\b_|_\b/g, "\\_");
        escapedText = escapedText.replace(/([<>])/g, "\\$1");
        state.text(escapedText, false);
    } });
// extend the default markdown serializer's nodes and add our own
var customMarkdownSerializerNodes = {
    // TODO
    html_inline: function (state, node) {
        state.write(node.attrs.content);
        state.ensureNewLine();
        state.write("\n");
    },
    // TODO
    html_block: function (state, node) {
        state.write(node.attrs.content);
        state.ensureNewLine();
        state.write("\n");
    },
    // TODO
    html_block_container: function (state, node) {
        state.write(node.attrs.contentOpen);
        // ensure the opening content had a newline and write a newline
        // since that terminated the html_block and caused the container creation
        state.ensureNewLine();
        state.write("\n");
        state.renderContent(node);
        state.write(node.attrs.contentClose);
        state.closeBlock(node);
    },
    // write softbreaks back to a newline character
    softbreak: function (state) {
        state.write("\n");
    },
    table: function (state, node) {
        function serializeTableHead(head) {
            var columnAlignments = [];
            head.forEach(function (headRow) {
                if (headRow.type === richTextSchema.nodes.table_row) {
                    columnAlignments = serializeTableRow(headRow);
                }
            });
            // write table header separator
            for (var _i = 0, columnAlignments_1 = columnAlignments; _i < columnAlignments_1.length; _i++) {
                var alignment = columnAlignments_1[_i];
                state.write("|");
                state.write(alignment === "left" || alignment === "center" ? ":" : " ");
                state.write("---");
                state.write(alignment === "right" || alignment === "center" ? ":" : " ");
            }
            state.write("|");
            state.ensureNewLine();
        }
        function serializeTableBody(body) {
            body.forEach(function (bodyRow) {
                if (bodyRow.type === richTextSchema.nodes.table_row) {
                    serializeTableRow(bodyRow);
                }
            });
            state.ensureNewLine();
        }
        function serializeTableRow(row) {
            var columnAlignment = [];
            row.forEach(function (cell) {
                if (cell.type === richTextSchema.nodes.table_header ||
                    cell.type === richTextSchema.nodes.table_cell) {
                    var alignment = serializeTableCell(cell);
                    columnAlignment.push(alignment);
                }
            });
            state.write("|");
            state.ensureNewLine();
            return columnAlignment;
        }
        function serializeTableCell(cell) {
            state.write("| ");
            state.renderInline(cell);
            state.write(" ");
            return findAlignment(cell);
        }
        function findAlignment(cell) {
            var alignment = cell.attrs.style;
            if (!alignment) {
                return null;
            }
            // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
            var match = alignment.match(/text-align:[ ]?(left|right|center)/);
            if (match && match[1]) {
                return match[1];
            }
            return null;
        }
        node.forEach(function (table_child) {
            if (table_child.type === richTextSchema.nodes.table_head)
                serializeTableHead(table_child);
            if (table_child.type === richTextSchema.nodes.table_body)
                serializeTableBody(table_child);
        });
        state.ensureNewLine();
        state.write("\n");
    },
    tagLink: function (state, node) {
        var isMeta = node.attrs.tagType === "meta-tag";
        var prefix = isMeta ? "meta-tag" : "tag";
        var tag = node.attrs.tagName;
        state.write("[" + prefix + ":" + tag + "]");
    },
    spoiler: function (state, node) {
        state.wrapBlock(">! ", null, node, function () { return state.renderContent(node); });
    },
};
/**
 * Generates a config from a base config that is aware of special "markup" added by the markdown tokenizer;
 * typically this will be differences in how markdown can be written (e.g. * vs _ for emphasis),
 * but could also be html tags from our extended html support plugin (e.g. * vs <em> for emphasis)
 * @param config The base config to extend
 */
function genMarkupAwareMarkConfig(config) {
    // we don't support function open/close since these could have fairly complicated logic in them
    if (config.open instanceof Function || config.close instanceof Function) {
        // log an error to the console and return the unmodified base config
        error("markdown-serializer genMarkupAwareMarkSpec", "Unable to extend mark config with open/close as functions", config);
        return config;
    }
    return __assign(__assign({}, config), { open: function (_, mark) {
            var markup = mark.attrs.markup;
            return markup || config.open;
        }, close: function (_, mark) {
            var markup = mark.attrs.markup;
            // insert the `/` on html closing tags
            markup = /^<[a-z]+>$/i.test(markup)
                ? markup.replace(/^</, "</")
                : markup;
            return markup || config.close;
        } });
}
// add support for html/linkify marked-up links (defaulting back to the default serializer otherwise)
var defaultLinkMarkDeserializer = defaultMarkdownSerializer.marks
    .link;
var extendedLinkMarkDeserializer = {
    open: function (state, mark, parent, index) {
        if (!mark.attrs.markup) {
            return typeof defaultLinkMarkDeserializer.open === "string"
                ? defaultLinkMarkDeserializer.open
                : defaultLinkMarkDeserializer.open(state, mark, parent, index);
        }
        // linkify detected links are left bare
        if (mark.attrs.markup === "linkify") {
            return "";
        }
        if (mark.attrs.markup === "autolink") {
            return "<";
        }
        var titleAttr = mark.attrs.title
            ? " title=\"" + mark.attrs.title + "\""
            : "";
        var hrefAttr = mark.attrs.href
            ? " href=\"" + mark.attrs.href + "\""
            : "";
        return "<a" + hrefAttr + titleAttr + ">";
    },
    close: function (state, mark, parent, index) {
        if (!mark.attrs.markup) {
            return typeof defaultLinkMarkDeserializer.close === "string"
                ? defaultLinkMarkDeserializer.close
                : defaultLinkMarkDeserializer.close(state, mark, parent, index);
        }
        // linkify detected links are left bare
        if (mark.attrs.markup === "linkify") {
            return "";
        }
        if (mark.attrs.markup === "autolink") {
            return ">";
        }
        return "</a>";
    },
};
// add support for <code> markup
var defaultCodeMarkDeserializer = defaultMarkdownSerializer.marks
    .code;
var extendedCodeMarkDeserializer = {
    open: function (state, mark, parent, index) {
        if (typeof defaultCodeMarkDeserializer.open === "string") {
            return (mark.attrs.markup ||
                defaultCodeMarkDeserializer.open);
        }
        // run the backing method to get where the markup should be placed
        // TODO the types are incorrect, the correct return type is "string", not "void"
        var defaultResult = defaultCodeMarkDeserializer.open(state, mark, parent, index);
        if (mark.attrs.markup) {
            defaultResult = defaultResult.replace("`", mark.attrs.markup);
        }
        return defaultResult;
    },
    close: function (state, mark, parent, index) {
        if (typeof defaultCodeMarkDeserializer.close === "string") {
            return (mark.attrs.markup ||
                defaultCodeMarkDeserializer.open);
        }
        // run the backing method to get where the markup should be placed
        // TODO the types are incorrect, the correct return type is "string", not "void"
        var defaultResult = defaultCodeMarkDeserializer.close(state, mark, parent, index);
        if (mark.attrs.markup) {
            // insert the `/` on html closing tags
            var markup = mark.attrs.markup.replace(/^</, "</");
            defaultResult = defaultResult.replace("`", markup);
        }
        return defaultResult;
    },
    escape: defaultCodeMarkDeserializer.escape,
};
// extend the default markdown serializer's marks and add our own
var customMarkdownSerializerMarks = __assign(__assign({}, defaultMarkdownSerializer.marks), {
    em: genMarkupAwareMarkConfig(defaultMarkdownSerializer.marks.em),
    strong: genMarkupAwareMarkConfig(defaultMarkdownSerializer.marks.strong),
    code: extendedCodeMarkDeserializer,
    link: extendedLinkMarkDeserializer,
    strike: genMarkupAwareMarkConfig({
        open: "~~",
        close: "~~",
        mixable: true,
        expelEnclosingWhitespace: true,
    }),
    kbd: genMarkupAwareMarkConfig({
        open: "<kbd>",
        close: "</kbd>",
        mixable: true,
        expelEnclosingWhitespace: true,
    }),
    sup: genMarkupAwareMarkConfig({
        open: "<sup>",
        close: "</sup>",
        mixable: true,
        expelEnclosingWhitespace: true,
    }),
    sub: genMarkupAwareMarkConfig({
        open: "<sub>",
        close: "</sub>",
        mixable: true,
        expelEnclosingWhitespace: true,
    }),
});
// export our custom serializer using the extended nodes/marks taken from the default schema
export var stackOverflowMarkdownSerializer = function (externalPlugin) {
    return new MarkdownSerializer(__assign(__assign(__assign({}, defaultMarkdownSerializerNodes), customMarkdownSerializerNodes), externalPlugin.markdownSerializers), customMarkdownSerializerMarks);
};
