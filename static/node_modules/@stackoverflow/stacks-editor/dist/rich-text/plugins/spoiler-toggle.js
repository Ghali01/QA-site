var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Plugin } from "prosemirror-state";
import { docChanged } from "../../shared/utils";
/**
 * Updates all spoiler nodes within the state's selection
 * @param tr The transaction to modify
 * @param state The state whose selection to check for spoiler nodes (does not have to be the current state!)
 * @param shouldReveal Whether to force the spoiler to be revealed or not
 * @param transactions The array of transactions to map node positions through (if the state is not current)
 */
function updateSpoilers(tr, state, shouldReveal, transactions) {
    var _a = state.selection, from = _a.from, to = _a.to;
    state.doc.nodesBetween(from, to, function (node, pos) {
        // if spoiler node, set revealed attribute
        if (node.type.name === "spoiler") {
            // inherit whatever attributes are already on the node,
            // but do NOT update the node directly (or else the view will not register as changed)
            var attrs = __assign({}, node.attrs);
            attrs.revealed = shouldReveal;
            var wasDeleted_1 = false;
            if (transactions === null || transactions === void 0 ? void 0 : transactions.length) {
                // map the position through each transaction to make sure the node we're altering still exists
                transactions.forEach(function (t) {
                    var result = t.mapping.mapResult(pos);
                    // if the node was outright deleted, skip it!
                    if (result.deleted) {
                        wasDeleted_1 = true;
                        return false;
                    }
                    // set pos to the current position of the node
                    pos = result.pos;
                });
            }
            // if the node was deleted, then there's nothing to do
            if (wasDeleted_1) {
                return false;
            }
            tr = tr.setNodeMarkup(pos, null, attrs);
            // don't recurse into this node's children
            return false;
        }
    });
    return tr;
}
/** Plugin that forces the `revealed` attr on "spoiler" nodes on selection and removes it on de-selection */
export var spoilerToggle = new Plugin({
    appendTransaction: function (transactions, oldState, newState) {
        // if the doc / selection has not changed, nothing to do
        if (!docChanged(oldState, newState)) {
            return null;
        }
        var tr = newState.tr;
        // un-reveal all spoilers from the old state/selection
        tr = updateSpoilers(tr, oldState, false, transactions);
        // reveal all spoilers in the new selection
        tr = updateSpoilers(tr, newState, true);
        // no nodes changed, just return
        if (!tr.steps.length) {
            return null;
        }
        // make sure this doesn't get added to the history
        tr = tr.setMeta("addToHistory", false);
        return tr;
    },
});
