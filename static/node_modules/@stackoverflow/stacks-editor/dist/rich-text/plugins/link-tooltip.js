var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { toggleMark } from "prosemirror-commands";
import { TextSelection } from "prosemirror-state";
import { Decoration, DecorationSet } from "prosemirror-view";
import { StatefulPlugin, StatefulPluginKey, } from "../../shared/prosemirror-plugins/plugin-extensions";
import { richTextSchema as schema } from "../../shared/schema";
import { escapeHTML, validateLink } from "../../shared/utils";
var LinkTooltip = /** @class */ (function () {
    function LinkTooltip(state) {
        var _this = this;
        this.content = document.createElement("span");
        this.content.className = "w0";
        this.content.setAttribute("aria-controls", "link-tooltip-popover");
        this.content.setAttribute("data-controller", "s-popover");
        this.content.setAttribute("data-s-popover-placement", "bottom");
        // TODO localization (everywhere we have harcoded template strings)
        this.content.innerHTML = escapeHTML(templateObject_1 || (templateObject_1 = __makeTemplateObject(["<div class=\"s-popover is-visible p4 w-auto wmx-initial wmn-initial js-link-tooltip\"\n            id=\"link-tooltip-popover\"\n            role=\"menu\">\n            <div class=\"s-popover--arrow\"></div>\n            <div class=\"d-flex ai-center\">\n                <a href=\"", "\"\n                    class=\"wmx3 flex--item fs-body1 fw-normal truncate ml8 mr4\"\n                    target=\"_blank\"\n                    rel=\"nofollow noreferrer\">", "</a>\n                <div class=\"flex--item d-none wmn2 ml2 mr4 mb0 js-link-tooltip-input-wrapper\">\n                    <input type=\"text\"\n                            class=\"s-input s-input__sm js-link-tooltip-input\"\n                            autocomplete=\"off\"\n                            name=\"link\"\n                            value=\"", "\" />\n                </div>\n                <button type=\"button\"\n                        class=\"flex--item s-btn mr4 js-link-tooltip-edit\"\n                        title=\"", "\"><span class=\"svg-icon icon-bg iconPencilSm\"></span></button>\n                <button type=\"button\"\n                        class=\"flex--item s-btn d-none js-link-tooltip-apply\"\n                        title=\"", "\">", "</button>\n                <button type=\"button\"\n                        class=\"flex--item s-btn js-link-tooltip-remove\"\n                        title=\"", "\"><span class=\"svg-icon icon-bg iconTrashSm\"></span></button>\n            </div>\n        </div>"], ["<div class=\"s-popover is-visible p4 w-auto wmx-initial wmn-initial js-link-tooltip\"\n            id=\"link-tooltip-popover\"\n            role=\"menu\">\n            <div class=\"s-popover--arrow\"></div>\n            <div class=\"d-flex ai-center\">\n                <a href=\"", "\"\n                    class=\"wmx3 flex--item fs-body1 fw-normal truncate ml8 mr4\"\n                    target=\"_blank\"\n                    rel=\"nofollow noreferrer\">", "</a>\n                <div class=\"flex--item d-none wmn2 ml2 mr4 mb0 js-link-tooltip-input-wrapper\">\n                    <input type=\"text\"\n                            class=\"s-input s-input__sm js-link-tooltip-input\"\n                            autocomplete=\"off\"\n                            name=\"link\"\n                            value=\"", "\" />\n                </div>\n                <button type=\"button\"\n                        class=\"flex--item s-btn mr4 js-link-tooltip-edit\"\n                        title=\"", "\"><span class=\"svg-icon icon-bg iconPencilSm\"></span></button>\n                <button type=\"button\"\n                        class=\"flex--item s-btn d-none js-link-tooltip-apply\"\n                        title=\"", "\">", "</button>\n                <button type=\"button\"\n                        class=\"flex--item s-btn js-link-tooltip-remove\"\n                        title=\"", "\"><span class=\"svg-icon icon-bg iconTrashSm\"></span></button>\n            </div>\n        </div>"])), this.href, this.href, this.href, "Edit link", "Apply new link", "Apply", "Remove link");
        // never allow the popover to hide itself. It either exists visibly or not at all
        this.content.addEventListener("s-popover:hide", function (e) {
            e.preventDefault();
        });
        // don't bind the exact listener, call whatever is currently set on `this` at event time
        var removeListener = function (e) {
            _this.removeListener.call(_this, e);
        };
        // same as above, don't bind directly
        var applyListener = function (e) {
            _this.applyListener.call(_this, e);
        };
        // prevent form submits on ENTER press and apply changes instead
        this.input.addEventListener("keydown", function (e) {
            if (e.key === "Enter") {
                e.stopPropagation();
                e.preventDefault();
                applyListener(e);
            }
        });
        // hook up the click/keyboard events for the supporting buttons
        this.bindElementInteraction(this.applyButton, applyListener);
        this.bindElementInteraction(this.removeButton, removeListener);
        this.bindElementInteraction(this.editButton, function () {
            _this.showEditMode(_this.href);
        });
        this.editing = false;
        this.update(state);
    }
    Object.defineProperty(LinkTooltip.prototype, "editButton", {
        get: function () {
            return this.content.querySelector(".js-link-tooltip-edit");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkTooltip.prototype, "applyButton", {
        get: function () {
            return this.content.querySelector(".js-link-tooltip-apply");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkTooltip.prototype, "removeButton", {
        get: function () {
            return this.content.querySelector(".js-link-tooltip-remove");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkTooltip.prototype, "link", {
        get: function () {
            return this.content.querySelector("a");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkTooltip.prototype, "input", {
        get: function () {
            return this.content.querySelector(".js-link-tooltip-input");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkTooltip.prototype, "inputWrapper", {
        get: function () {
            return this.content.querySelector(".js-link-tooltip-input-wrapper");
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Binds both a mousedown and selective keydown listener to replace the purposefully missing "click" event
     * @param element The element to bind the events to
     * @param callback The callback to run on mousedown/keydown
     */
    LinkTooltip.prototype.bindElementInteraction = function (element, callback) {
        var _this = this;
        element.addEventListener("mousedown", function (e) {
            e.stopPropagation();
            e.preventDefault();
            callback.call(_this, e);
        });
        element.addEventListener("keydown", function (e) {
            // allow the Tab key to keep doing its thing
            if (e.key === "Tab") {
                return;
            }
            // cancel all other keypresses
            e.stopPropagation();
            e.preventDefault();
            // enter/space should still fire the event as if clicked
            if (e.key === "Enter" || e.key === " ") {
                callback.call(_this, e);
            }
        });
    };
    /**
     * Updates the internal state / tooltip visuals based on the current editor state
     * @param state the current state of the editor
     */
    LinkTooltip.prototype.update = function (state) {
        if (!this.isLink(state)) {
            return;
        }
        var linkMarks = this.findMarksInSelection(state);
        if (linkMarks.length > 0) {
            this.href = linkMarks[0].attrs.href;
            var link = this.link;
            link.href = link.title = link.innerText = this.href;
        }
        // if we can toggle the mark and actually found an href to display, show the tooltip
        if (toggleMark(schema.marks.link)(state) && this.href) {
            this.hideEditMode();
        }
        if (this.editing || this.href === "") {
            this.showEditMode(this.href);
        }
    };
    /**
     * Gets the tooltip decoration from a new PluginState.apply call
     * @param tr The transaction that was applied (to map existing decorations)
     * @param value The existing LinkTooltipState (with forceHidden potentially set)
     * @param oldState The state before the transaction
     * @param newState The state after the transaction
     */
    LinkTooltip.prototype.getDecorations = function (tr, value, oldState, newState) {
        var _this = this;
        // if we're forced to hide the decorations, don't even attempt to create them
        if ("forceHide" in value && value.forceHide) {
            return DecorationSet.empty;
        }
        var marks = this.findMarksInSelection(newState);
        // if there are no marks in the current selection, then return empty
        if (!marks.length) {
            return DecorationSet.empty;
        }
        // always update the state, regardless of document changes (potential metadata changes can change tooltip visuals)
        this.update(newState);
        // create the widget tooltip via EditorView callback
        var decoration = Decoration.widget(newState.selection.from, function (view) {
            /* NOTE: This function runs on every transaction update */
            _this.updateEventListeners(view);
            return _this.content;
        }, {
            // place the widget *before* the cursor so it isn't included in text selections
            side: -1,
            ignoreSelection: true,
            // cancel all events coming from inside this widget
            stopEvent: function () { return true; },
        });
        return DecorationSet.create(newState.doc, [decoration]);
    };
    /**
     * Returns true if the focus event caused something in the content to be focused
     * @param e The dispatched focus event
     */
    LinkTooltip.prototype.hasFocus = function (e) {
        return this.content.contains(e.relatedTarget);
    };
    /**
     * Find out if the current selection contains a link mark
     * @param state The current editor state
     */
    LinkTooltip.prototype.isLink = function (state) {
        var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
        if (!empty) {
            return state.doc.rangeHasMark(from, to, schema.marks.link);
        }
        return (schema.marks.link.isInSet(state.storedMarks || $from.marks()) !==
            undefined);
    };
    /**
     * Shows the input for href editing and focuses it
     * @param url
     */
    LinkTooltip.prototype.showEditMode = function (url) {
        this.hideValidationError();
        var input = this.input;
        input.value = url || "https://";
        this.inputWrapper.classList.remove("d-none");
        input.select();
        this.applyButton.classList.remove("d-none");
        this.editButton.classList.add("d-none");
        this.link.classList.add("d-none");
        input.focus();
    };
    /**
     * Hides the href focus input and changes back to view mode
     */
    LinkTooltip.prototype.hideEditMode = function () {
        this.editButton.classList.remove("d-none");
        this.link.classList.remove("d-none");
        this.inputWrapper.classList.add("d-none");
        this.applyButton.classList.add("d-none");
    };
    /** Marks the input with a visual validation error */
    LinkTooltip.prototype.showValidationError = function () {
        this.inputWrapper.classList.add("has-error");
    };
    /** Clears the input of any visual validation errors */
    LinkTooltip.prototype.hideValidationError = function () {
        this.inputWrapper.classList.remove("has-error");
    };
    /**
     * Expand the current selection to contain the entire link mark.
     * This allows us to remove the link mark from the entire link in the document
     * if the user didn't explicitly select a region to be toggled.
     */
    LinkTooltip.prototype.expandSelection = function (state, tr) {
        var expanded = this.linkAround(state);
        tr = tr.setSelection(TextSelection.create(tr.doc, expanded.from, expanded.to));
        return tr;
    };
    /**
     * Gets the positions immediately before and after a link mark in the current selection
     * @param state
     */
    LinkTooltip.prototype.linkAround = function (state) {
        var $pos = state.selection.$from;
        var start = $pos.parent.childAfter($pos.parentOffset);
        if (!start.node) {
            return;
        }
        var link = start.node.marks.find(function (mark) { return mark.type === state.schema.marks.link; });
        if (!link) {
            return;
        }
        var startIndex = $pos.index();
        var startPos = $pos.start() + start.offset;
        while (startIndex > 0 &&
            link.isInSet($pos.parent.child(startIndex - 1).marks)) {
            startIndex -= 1;
            startPos -= $pos.parent.child(startIndex).nodeSize;
        }
        var endIndex = $pos.indexAfter();
        var endPos = startPos + start.node.nodeSize;
        while (endIndex < $pos.parent.childCount &&
            link.isInSet($pos.parent.child(endIndex).marks)) {
            endPos += $pos.parent.child(endIndex).nodeSize;
            endIndex += 1;
        }
        return { from: startPos, to: endPos };
    };
    /**
     * Finds all marks in the current selection
     * @param state The current editor state
     */
    LinkTooltip.prototype.findMarksInSelection = function (state) {
        var linkMarks = [];
        var _a = state.selection, to = _a.to, from = _a.from, $from = _a.$from, empty = _a.empty;
        if (empty) {
            return $from
                .marks()
                .filter(function (mark) { return mark.type === schema.marks.link; });
        }
        if (to > from) {
            state.doc.nodesBetween(from, to, function (node) {
                linkMarks.push(node.marks.filter(function (mark) { return mark.type === schema.marks.link; }));
            });
        }
        var returnValue = [];
        return returnValue.concat.apply(returnValue, linkMarks);
    };
    /**
     * Updates apply/delete button events with the current editor view
     * @param view The current editor view
     */
    LinkTooltip.prototype.updateEventListeners = function (view) {
        var _this = this;
        this.removeListener = function () {
            var state = view.state;
            if (view.state.selection.empty) {
                // TODO chain the double dispatch!
                view.dispatch(_this.expandSelection(state, view.state.tr));
                state = view.state;
            }
            toggleMark(schema.marks.link)(state, view.dispatch.bind(view));
        };
        this.applyListener = function () {
            var link = _this.link;
            var input = _this.input;
            var _a = view.state.selection, from = _a.from, to = _a.to;
            _this.editing = false;
            // the input stole focus from the editor, so reset focus
            view.focus();
            // if the link didn't change, close and move on
            if (link.href === input.value) {
                _this.hideEditMode();
                return;
            }
            _this.hideValidationError();
            // validate link
            if (!validateLink(input.value)) {
                _this.showValidationError();
                return;
            }
            link.href = link.title = link.innerText = input.value;
            if (view.state.selection.empty) {
                var expanded = _this.linkAround(view.state);
                from = expanded.from;
                to = expanded.to;
            }
            var tr = view.state.tr.addMark(from, to, schema.marks.link.create({ href: _this.link.href }));
            view.dispatch(tr);
        };
    };
    return LinkTooltip;
}());
/**
 * Custom PluginKey with additional methods for interacting with a LinkTooltip
 */
var LinkTooltipPluginKey = /** @class */ (function (_super) {
    __extends(LinkTooltipPluginKey, _super);
    function LinkTooltipPluginKey() {
        return _super.call(this, LinkTooltip.name) || this;
    }
    /**
     * Launch the link tooltip in edit mode
     */
    LinkTooltipPluginKey.prototype.setEditMode = function (isEditing, state, tr) {
        // set edit mode on the link tooltip
        var meta = this.getState(state);
        meta.editing = isEditing;
        // signal to the view that an update has been made
        return this.setMeta(tr, meta);
    };
    /**
     * Force the link tooltip to hide - useful e.g. when the entire editor is losing
     * focus and we want to make sure the tooltip disappears, too
     */
    LinkTooltipPluginKey.prototype.forceHide = function (state, dispatch) {
        var meta = this.getState(state);
        // if the tooltip is not showing, just return
        if (meta.decorations === DecorationSet.empty) {
            return;
        }
        meta.forceHide = true;
        var tr = this.setMeta(state.tr, meta);
        // immediately dispatch
        dispatch(tr);
    };
    return LinkTooltipPluginKey;
}(StatefulPluginKey));
export var LINK_TOOLTIP_KEY = new LinkTooltipPluginKey();
/**
 * A plugin view that shows a tooltip when selecting a link in rich-text mode.
 * The tooltip shows the href attribute of the selected link and allows removing
 * the link mark from the document.
 *
 * Note: This is not a _NodeView_ because when dealing with links, we're dealing with
 * _marks_, not _nodes_.
 */
export var linkTooltipPlugin = new StatefulPlugin({
    key: LINK_TOOLTIP_KEY,
    state: {
        init: function (_, instance) {
            return {
                linkTooltip: new LinkTooltip(instance),
                decorations: DecorationSet.empty,
            };
        },
        apply: function (tr, value, oldState, newState) {
            // check if force hide was set and add to value for getDecorations to use
            var meta = this.getMeta(tr) || value;
            if ("forceHide" in meta) {
                value.forceHide = meta.forceHide;
            }
            // check for editing as well
            value.linkTooltip.editing =
                "editing" in meta ? meta.editing : false;
            // update the linkTooltip and get the decorations
            var decorations = value.linkTooltip.getDecorations(tr, value, oldState, newState);
            // always return a "fresh" state with just the required items set
            return {
                linkTooltip: value.linkTooltip,
                decorations: decorations,
            };
        },
    },
    props: {
        decorations: function (state) {
            return this.getState(state).decorations;
        },
        handleDOMEvents: {
            /** Handle editor blur and close the tooltip if it isn't focused */
            blur: function (view, e) {
                var linkTooltip = LINK_TOOLTIP_KEY.getState(view.state).linkTooltip;
                // if the editor blurs, but NOT because of the tooltip, hide the tooltip
                if (!view.hasFocus() && !linkTooltip.hasFocus(e)) {
                    LINK_TOOLTIP_KEY.forceHide(view.state, view.dispatch.bind(view));
                }
                // always return false since we're not cancelling/handling the blur
                return false;
            },
        },
    },
});
var templateObject_1;
