import { InputRule, inputRules, textblockTypeInputRule, wrappingInputRule, } from "prosemirror-inputrules";
import { richTextSchema as schema } from "../shared/schema";
import { validateLink } from "../shared/utils";
var blockquoteInputRule = wrappingInputRule(/^\s*>\s$/, schema.nodes.blockquote);
var spoilerInputRule = wrappingInputRule(/^\s*>!\s$/, schema.nodes.spoiler);
var headingInputRule = textblockTypeInputRule(new RegExp("^(#{1,3})\\s$"), schema.nodes.heading, function (match) { return ({ level: match[1].length }); });
var codeBlockRule = textblockTypeInputRule(/^```$/, schema.nodes.code_block);
var unorderedListRule = wrappingInputRule(/^\s*[*+-]\s$/, schema.nodes.bullet_list);
var orderedListRule = wrappingInputRule(/^\s*\d(\.|\))\s$/, schema.nodes.ordered_list, function (match) { return ({ order: +match[1] }); }, function (match, node) { return node.childCount + node.attrs.order == +match[1]; });
// matches: `some text`, but not ` text `
var inlineCodeRegex = /`(\S(?:|.*?\S))`$/;
// matches: **some text**, but not ** text **
var strongRegexAsterisks = /\*\*(\S(?:|.*?\S))\*\*$/;
// matches: *some text*, but not **text* or * text *
export var emphasisRegexAsterisk = /\*([^*\s]([^*])*[^*\s]|[^*\s])\*$/;
// matches: __some text__, but not __ text __
var strongRegexUnderscores = /__(\S(?:|.*?\S))__$/;
// matches: _some text_, but not __text_ or _ text _
var emphasisRegexUnderscore = /_([^_\s]([^_])*[^_\s]|[^_\s])_$/;
// matches: [ *any* thing ]( any thing )
var linkRegex = /\[(.+)\]\((.+)\)$/;
var inlineCodeRule = markInputRule(inlineCodeRegex, schema.marks.code);
var boldRule = markInputRule(strongRegexAsterisks, schema.marks.strong);
var emphasisRule = markInputRule(emphasisRegexAsterisk, schema.marks.em, function (match) { return match.input.charAt(match.input.lastIndexOf(match[0]) - 1) !== "*"; });
var boldUnderlineRule = markInputRule(strongRegexUnderscores, schema.marks.strong);
var emphasisUnderlineRule = markInputRule(emphasisRegexUnderscore, schema.marks.em, function (match) { return match.input.charAt(match.input.lastIndexOf(match[0]) - 1) !== "_"; });
var linkRule = markInputRule(linkRegex, schema.marks.link, function (match) { return validateLink(match[2]); }, // only apply link input rule, if the matched URL is valid,
function (match) {
    return { href: match[2] };
});
/**
 * Create an input rule that applies a mark to the text matched by a regular expression.
 * @param regexp The regular expression to match the text. The text to be wrapped in a mark needs to be marked by the _first_ capturing group.
 * @param markType The mark type to apply
 * @param getAttrs A function returning the attributes to be applied to the node
 * @param matchValidator An optional function that allows validating the match before applying the mark
 * @returns A mark input rule
 */
function markInputRule(regexp, markType, matchValidator, getAttrs) {
    return new InputRule(regexp, function (state, match, start, end) {
        var attrs = getAttrs ? getAttrs(match) : {};
        var tr = state.tr;
        // if the current node doesn't allow this mark, don't attempt to transform
        if (!state.doc.resolve(start).parent.type.allowsMarkType(markType)) {
            return null;
        }
        // validate the match if a validator is given
        // and skip applying the mark if the validation fails
        if (matchValidator && !matchValidator(match)) {
            return null;
        }
        var matchedString = match[0];
        var capturedGroup = match[1];
        if (capturedGroup) {
            var textStart = start + matchedString.indexOf(capturedGroup);
            var textEnd = textStart + capturedGroup.length;
            if (textEnd < end) {
                tr.delete(textEnd, end);
            }
            if (textStart > start) {
                tr.delete(start, textStart);
            }
            end = start + capturedGroup.length;
        }
        // add mark to matching text
        tr.addMark(start, end, markType.create(attrs));
        // don't use mark for new text that's gonna follow
        tr.removeStoredMark(markType);
        return tr;
    });
}
/**
 * Defines all input rules we're using in our rich-text editor.
 * Input rules are formatting operations that trigger as you type based on regular expressions
 *
 * Examples:
 *      * starting a line with "# " will turn the line into a headline
 *      * starting a line with "> " will insert a new blockquote in place
 */
export var richTextInputRules = inputRules({
    rules: [
        blockquoteInputRule,
        spoilerInputRule,
        headingInputRule,
        codeBlockRule,
        unorderedListRule,
        orderedListRule,
        inlineCodeRule,
        boldRule,
        boldUnderlineRule,
        emphasisRule,
        emphasisUnderlineRule,
        linkRule,
    ],
});
